nimTitle	atomics	atomics.html	module std/atomics		0
nim	MemoryOrder	atomics.html#MemoryOrder	enum MemoryOrder		60
nim	Atomic	atomics.html#Atomic	object Atomic		92
nim	AtomicFlag	atomics.html#AtomicFlag	object AtomicFlag		96
nim	load	atomics.html#load,Atomic[T],MemoryOrder	proc load[T](location: var Atomic[T]; order: MemoryOrder = moSequentiallyConsistent): T		101
nim	store	atomics.html#store,Atomic[T],T,MemoryOrder	proc store[T](location: var Atomic[T]; desired: T;\n         order: MemoryOrder = moSequentiallyConsistent)		104
nim	exchange	atomics.html#exchange,Atomic[T],T,MemoryOrder	proc exchange[T](location: var Atomic[T]; desired: T;\n            order: MemoryOrder = moSequentiallyConsistent): T		108
nim	compareExchange	atomics.html#compareExchange,Atomic[T],T,T,MemoryOrder	proc compareExchange[T](location: var Atomic[T]; expected: var T; desired: T;\n                   order: MemoryOrder = moSequentiallyConsistent): bool		112
nim	compareExchange	atomics.html#compareExchange,Atomic[T],T,T,MemoryOrder,MemoryOrder	proc compareExchange[T](location: var Atomic[T]; expected: var T; desired: T;\n                   success, failure: MemoryOrder): bool		117
nim	compareExchangeWeak	atomics.html#compareExchangeWeak,Atomic[T],T,T,MemoryOrder	proc compareExchangeWeak[T](location: var Atomic[T]; expected: var T; desired: T;\n                       order: MemoryOrder = moSequentiallyConsistent): bool		121
nim	compareExchangeWeak	atomics.html#compareExchangeWeak,Atomic[T],T,T,MemoryOrder,MemoryOrder	proc compareExchangeWeak[T](location: var Atomic[T]; expected: var T; desired: T;\n                       success, failure: MemoryOrder): bool		124
nim	fetchAdd	atomics.html#fetchAdd,Atomic[T: SomeInteger],T,MemoryOrder	proc fetchAdd[T: SomeInteger](location: var Atomic[T]; value: T;\n                         order: MemoryOrder = moSequentiallyConsistent): T		130
nim	fetchSub	atomics.html#fetchSub,Atomic[T: SomeInteger],T,MemoryOrder	proc fetchSub[T: SomeInteger](location: var Atomic[T]; value: T;\n                         order: MemoryOrder = moSequentiallyConsistent): T		134
nim	fetchAnd	atomics.html#fetchAnd,Atomic[T: SomeInteger],T,MemoryOrder	proc fetchAnd[T: SomeInteger](location: var Atomic[T]; value: T;\n                         order: MemoryOrder = moSequentiallyConsistent): T		138
nim	fetchOr	atomics.html#fetchOr,Atomic[T: SomeInteger],T,MemoryOrder	proc fetchOr[T: SomeInteger](location: var Atomic[T]; value: T;\n                        order: MemoryOrder = moSequentiallyConsistent): T		142
nim	fetchXor	atomics.html#fetchXor,Atomic[T: SomeInteger],T,MemoryOrder	proc fetchXor[T: SomeInteger](location: var Atomic[T]; value: T;\n                         order: MemoryOrder = moSequentiallyConsistent): T		146
nim	testAndSet	atomics.html#testAndSet,AtomicFlag,MemoryOrder	proc testAndSet(location: var AtomicFlag;\n           order: MemoryOrder = moSequentiallyConsistent): bool		152
nim	clear	atomics.html#clear,AtomicFlag,MemoryOrder	proc clear(location: var AtomicFlag; order: MemoryOrder = moSequentiallyConsistent)		155
nim	fence	atomics.html#fence,MemoryOrder	proc fence(order: MemoryOrder)		158
nim	signalFence	atomics.html#signalFence,MemoryOrder	proc signalFence(order: MemoryOrder)		161
nim	atomicInc	atomics.html#atomicInc,Atomic[T: SomeInteger],T	proc atomicInc[T: SomeInteger](location: var Atomic[T]; value: T = 1)		401
nim	atomicDec	atomics.html#atomicDec,Atomic[T: SomeInteger],T	proc atomicDec[T: SomeInteger](location: var Atomic[T]; value: T = 1)		405
nim	`+=`	atomics.html#+=,Atomic[T: SomeInteger],T	proc `+=`[T: SomeInteger](location: var Atomic[T]; value: T)		409
nim	`-=`	atomics.html#-=,Atomic[T: SomeInteger],T	proc `-=`[T: SomeInteger](location: var Atomic[T]; value: T)		413
nimgrp	compareexchangeweak	atomics.html#compareExchangeWeak-procs-all	proc		121
nimgrp	compareexchange	atomics.html#compareExchange-procs-all	proc		112
