<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!--  This file is generated by Nim. -->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- Favicon -->
<link rel="shortcut icon" href="data:image/x-icon;base64,AAABAAEAEBAAAAEAIABoBAAAFgAAACgAAAAQAAAAIAAAAAEAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AAAAAAUAAAAF////AP///wD///8A////AP///wD///8A////AP///wD///8A////AAAAAAIAAABbAAAAlQAAAKIAAACbAAAAmwAAAKIAAACVAAAAWwAAAAL///8A////AP///wD///8A////AAAAABQAAADAAAAAYwAAAA3///8A////AP///wD///8AAAAADQAAAGMAAADAAAAAFP///wD///8A////AP///wAAAACdAAAAOv///wD///8A////AP///wD///8A////AP///wD///8AAAAAOgAAAJ3///8A////AP///wAAAAAnAAAAcP///wAAAAAoAAAASv///wD///8A////AP///wAAAABKAAAAKP///wAAAABwAAAAJ////wD///8AAAAAgQAAABwAAACIAAAAkAAAAJMAAACtAAAAFQAAABUAAACtAAAAkwAAAJAAAACIAAAAHAAAAIH///8A////AAAAAKQAAACrAAAAaP///wD///8AAAAARQAAANIAAADSAAAARf///wD///8AAAAAaAAAAKsAAACk////AAAAADMAAACcAAAAnQAAABj///8A////AP///wAAAAAYAAAAGP///wD///8A////AAAAABgAAACdAAAAnAAAADMAAAB1AAAAwwAAAP8AAADpAAAAsQAAAE4AAAAb////AP///wAAAAAbAAAATgAAALEAAADpAAAA/wAAAMMAAAB1AAAAtwAAAOkAAAD/AAAA/wAAAP8AAADvAAAA3gAAAN4AAADeAAAA3gAAAO8AAAD/AAAA/wAAAP8AAADpAAAAtwAAAGUAAAA/AAAA3wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAADfAAAAPwAAAGX///8A////AAAAAEgAAADtAAAAvwAAAL0AAADGAAAA7wAAAO8AAADGAAAAvQAAAL8AAADtAAAASP///wD///8A////AP///wD///8AAAAAO////wD///8A////AAAAAIcAAACH////AP///wD///8AAAAAO////wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A//8AAP//AAD4HwAA7/cAAN/7AAD//wAAoYUAAJ55AACf+QAAh+EAAAAAAADAAwAA4AcAAP5/AAD//wAA//8AAA=="/>
<link rel="icon" type="image/png" sizes="32x32" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAA3XAAAN1wFCKJt4AAAAB3RJTUUH4QQQEwksSS9ZWwAAAk1JREFUWMPtll2ITVEUx39nn/O7Y5qR8f05wtCUUr6ZIS++8pEnkZInPImneaCQ5METNdOkeFBKUhMPRIkHKfEuUZSUlGlKPN2TrgfncpvmnntnmlEyq1Z7t89/rf9a6+y99oZxGZf/XeIq61EdtgKXgdXA0xrYAvBjOIF1AI9zvjcC74BSpndrJPkBWDScTF8Aa4E3wDlgHbASaANmVqlcCnwHvgDvgVfAJ+AikAAvgfVZwLnSVZHZaOuKoQi3ZOMi4NkYkpe1p4J7A8BpYAD49hfIy/oqG0+hLomiKP2L5L+1ubn5115S+3OAn4EnwBlgMzCjyt6ZAnQCJ4A7wOs88iRJHvw50HoujuPBoCKwHWiosy8MdfZnAdcHk8dxXFJ3VQbQlCTJvRBCGdRbD4M6uc5glpY3eAihpN5S5w12diSEcCCEcKUO4ljdr15T76ur1FDDLIQQ3qv71EdDOe3Kxj3leRXyk+pxdWnFWod6Wt2bY3de3aSuUHcPBVimHs7mK9WrmeOF6lR1o9qnzskh2ar2qm1qizpfXaPeVGdlmGN5pb09qMxz1Xb1kLqgzn1RyH7JUXW52lr5e/Kqi9qpto7V1atuUzfnARrV7jEib1T76gG2qxdGmXyiekkt1GswPTtek0aBfJp6YySGBfWg2tPQ0FAYgf1stUfdmdcjarbYJEniKIq6gY/Aw+zWHAC+p2labGpqiorFYgGYCEzN7oQdQClN07O1/EfDyGgC0ALMBdYAi4FyK+4H3gLPsxfR1zRNi+NP7nH5J+QntnXe5B5mpfQAAAAASUVORK5CYII=">

<!-- Google fonts -->
<link href='https://fonts.googleapis.com/css?family=Lato:400,600,900' rel='stylesheet' type='text/css'/>
<link href='https://fonts.googleapis.com/css?family=Source+Code+Pro:400,500,600' rel='stylesheet' type='text/css'/>

<!-- CSS -->
<title>Nim Experimental Features</title>
<link rel="stylesheet" type="text/css" href="nimdoc.out.css">

<script type="text/javascript" src="dochack.js"></script>

<script type="text/javascript">
function main() {
  var pragmaDots = document.getElementsByClassName("pragmadots");
  for (var i = 0; i < pragmaDots.length; i++) {
    pragmaDots[i].onclick = function(event) {
      // Hide tease
      event.target.parentNode.style.display = "none";
      // Show actual
      event.target.parentNode.nextElementSibling.style.display = "inline";
    }
  }

  const toggleSwitch = document.querySelector('.theme-switch input[type="checkbox"]');
  function switchTheme(e) {
      if (e.target.checked) {
          document.documentElement.setAttribute('data-theme', 'dark');
          localStorage.setItem('theme', 'dark');
      } else {
          document.documentElement.setAttribute('data-theme', 'light');
          localStorage.setItem('theme', 'light');
      }
  }

  toggleSwitch.addEventListener('change', switchTheme, false);

  const currentTheme = localStorage.getItem('theme') ? localStorage.getItem('theme') : null;
  if (currentTheme) {
    document.documentElement.setAttribute('data-theme', currentTheme);

    if (currentTheme === 'dark') {
      toggleSwitch.checked = true;
    }
  }
}
</script>

</head>
<body onload="main()">
<div class="document" id="documentId">
  <div class="container">
    <h1 class="title">Nim Experimental Features</h1>
    <div class="row">
  <div class="three columns">
  <div class="theme-switch-wrapper">
    <label class="theme-switch" for="checkbox">
      <input type="checkbox" id="checkbox" />
      <div class="slider round"></div>
    </label>
    &nbsp;&nbsp;&nbsp; <em>Dark Mode</em>
  </div>
  <div id="global-links">
    <ul class="simple-boot">
      <li>
        <a href="manual.html">Manual</a>
      </li>
      <li>
        <a href="lib.html">Standard library</a>
      </li>
      <li>
        <a href="theindex.html">Index</a>
      </li>
      <li>
        <a href="compiler/theindex.html">Compiler docs</a>
      </li>
      <li>
        <a href="https://nim-lang.github.io/fusion/theindex.html">Fusion docs</a>
      </li>
    </ul>
  </div>
  <div id="searchInputDiv">
    Search: <input type="text" id="searchInput"
      onkeyup="search()" />
  </div>
    <div class="search-groupby">
    Group by:
    <select onchange="groupBy(this.value)">
      <option value="section">Section</option>
      <option value="type">Type</option>
    </select>
  </div>

  <ul class="simple simple-toc" id="toc-list">
<li><a class="reference" id="about-this-document_toc" href="#about-this-document">About this document</a></li>
<li><a class="reference" id="package-level-objects_toc" href="#package-level-objects">Package level objects</a></li>
<li><a class="reference" id="void-type_toc" href="#void-type">Void type</a></li>
<li><a class="reference" id="covariance_toc" href="#covariance">Covariance</a></li>
<li><a class="reference" id="automatic-dereferencing_toc" href="#automatic-dereferencing">Automatic dereferencing</a></li>
<li><a class="reference" id="code-reordering_toc" href="#code-reordering">Code reordering</a></li>
<li><a class="reference" id="named-argument-overloading_toc" href="#named-argument-overloading">Named argument overloading</a></li>
<li><a class="reference" id="do-notation_toc" href="#do-notation">Do notation</a></li>
<li><a class="reference" id="special-operators_toc" href="#special-operators">Special Operators</a></li>
<ul class="simple"><li><a class="reference" id="special-operators-dot-operators_toc" href="#special-operators-dot-operators">dot operators</a></li>
<li><a class="reference" id="special-operators-operator-dot_toc" href="#special-operators-operator-dot">operator <tt class="docutils literal"><span class="pre">.</span></tt></a></li>
<li><a class="reference" id="special-operators-operator-dot_toc" href="#special-operators-operator-dot">operator <tt class="docutils literal"><span class="pre">.()</span></tt></a></li>
<li><a class="reference" id="special-operators-operator-doteq_toc" href="#special-operators-operator-doteq">operator <tt class="docutils literal"><span class="pre">.=</span></tt></a></li>
</ul><li><a class="reference" id="not-nil-annotation_toc" href="#not-nil-annotation">Not nil annotation</a></li>
<li><a class="reference" id="concepts_toc" href="#concepts">Concepts</a></li>
<ul class="simple"><li><a class="reference" id="concepts-concept-diagnostics_toc" href="#concepts-concept-diagnostics">Concept diagnostics</a></li>
<li><a class="reference" id="concepts-generic-concepts-and-type-binding-rules_toc" href="#concepts-generic-concepts-and-type-binding-rules">Generic concepts and type binding rules</a></li>
<li><a class="reference" id="concepts-concept-derived-values_toc" href="#concepts-concept-derived-values">Concept derived values</a></li>
<li><a class="reference" id="concepts-concept-refinement_toc" href="#concepts-concept-refinement">Concept refinement</a></li>
</ul><li><a class="reference" id="type-bound-operations_toc" href="#type-bound-operations">Type bound operations</a></li>
<ul class="simple"><li><a class="reference" id="type-bound-operations-deepcopy_toc" href="#type-bound-operations-deepcopy">deepCopy</a></li>
</ul><li><a class="reference" id="case-statement-macros_toc" href="#case-statement-macros">Case statement macros</a></li>
<li><a class="reference" id="term-rewriting-macros_toc" href="#term-rewriting-macros">Term rewriting macros</a></li>
<ul class="simple"><li><a class="reference" id="term-rewriting-macros-parameter-constraints_toc" href="#term-rewriting-macros-parameter-constraints">Parameter constraints</a></li>
<li><a class="reference" id="term-rewriting-macros-pattern-operators_toc" href="#term-rewriting-macros-pattern-operators">Pattern operators</a></li>
<ul class="simple"><li><a class="reference" id="pattern-operators-the-bar-operator_toc" href="#pattern-operators-the-bar-operator">The <tt class="docutils literal"><span class="pre">|</span></tt> operator</a></li>
<li><a class="reference" id="pattern-operators-the-operator_toc" href="#pattern-operators-the-operator">The <tt class="docutils literal"><span class="pre">{}</span></tt> operator</a></li>
<li><a class="reference" id="pattern-operators-the-tilde-operator_toc" href="#pattern-operators-the-tilde-operator">The <tt class="docutils literal"><span class="pre">~</span></tt> operator</a></li>
<li><a class="reference" id="pattern-operators-the-star-operator_toc" href="#pattern-operators-the-star-operator">The <tt class="docutils literal"><span class="pre">*</span></tt> operator</a></li>
<li><a class="reference" id="pattern-operators-the-starstar-operator_toc" href="#pattern-operators-the-starstar-operator">The <tt class="docutils literal"><span class="pre">**</span></tt> operator</a></li>
</ul><li><a class="reference" id="term-rewriting-macros-parameters_toc" href="#term-rewriting-macros-parameters">Parameters</a></li>
<li><a class="reference" id="term-rewriting-macros-examplecolon-partial-evaluation_toc" href="#term-rewriting-macros-examplecolon-partial-evaluation">Example: Partial evaluation</a></li>
<li><a class="reference" id="term-rewriting-macros-examplecolon-hoisting_toc" href="#term-rewriting-macros-examplecolon-hoisting">Example: Hoisting</a></li>
</ul><li><a class="reference" id="ast-based-overloading_toc" href="#ast-based-overloading">AST based overloading</a></li>
<li><a class="reference" id="parallel-amp-spawn_toc" href="#parallel-amp-spawn">Parallel &amp; Spawn</a></li>
<ul class="simple"><li><a class="reference" id="parallel-amp-spawn-spawn-statement_toc" href="#parallel-amp-spawn-spawn-statement">Spawn statement</a></li>
<li><a class="reference" id="parallel-amp-spawn-parallel-statement_toc" href="#parallel-amp-spawn-parallel-statement">Parallel statement</a></li>
</ul><li><a class="reference" id="guards-and-locks_toc" href="#guards-and-locks">Guards and locks</a></li>
<ul class="simple"><li><a class="reference" id="guards-and-locks-guards-and-the-locks-section_toc" href="#guards-and-locks-guards-and-the-locks-section">Guards and the locks section</a></li>
<ul class="simple"><li><a class="reference" id="guards-and-the-locks-section-protecting-global-variables_toc" href="#guards-and-the-locks-section-protecting-global-variables">Protecting global variables</a></li>
<li><a class="reference" id="guards-and-the-locks-section-protecting-general-locations_toc" href="#guards-and-the-locks-section-protecting-general-locations">Protecting general locations</a></li>
</ul><li><a class="reference" id="guards-and-locks-lock-levels_toc" href="#guards-and-locks-lock-levels">Lock levels</a></li>
<li><a class="reference" id="guards-and-locks-norewrite-pragma_toc" href="#guards-and-locks-norewrite-pragma">noRewrite pragma</a></li>
</ul><li><a class="reference" id="taint-mode_toc" href="#taint-mode">Taint mode</a></li>
<li><a class="reference" id="aliasing-restrictions-in-parameter-passing_toc" href="#aliasing-restrictions-in-parameter-passing">Aliasing restrictions in parameter passing</a></li>
<li><a class="reference" id="noalias-annotation_toc" href="#noalias-annotation">Noalias annotation</a></li>
<li><a class="reference" id="strict-funcs_toc" href="#strict-funcs">Strict funcs</a></li>
<li><a class="reference" id="view-types_toc" href="#view-types">View types</a></li>
<ul class="simple"><li><a class="reference" id="view-types-path-expressions_toc" href="#view-types-path-expressions">Path expressions</a></li>
<li><a class="reference" id="view-types-start-of-a-borrow_toc" href="#view-types-start-of-a-borrow">Start of a borrow</a></li>
<li><a class="reference" id="view-types-end-of-a-borrow_toc" href="#view-types-end-of-a-borrow">End of a borrow</a></li>
<li><a class="reference" id="view-types-reborrows_toc" href="#view-types-reborrows">Reborrows</a></li>
<li><a class="reference" id="view-types-algorithm_toc" href="#view-types-algorithm">Algorithm</a></li>
</ul>
</ul>

  </div>
  &nbsp;&nbsp;<a
href="https://github.com/nim-lang/Nim/tree/devel/doc/manual_experimental.rst#L1"
class="link-seesrc" target="_blank">Source</a>
&nbsp;&nbsp;<a href="https://github.com/nim-lang/Nim/edit/devel/doc/manual_experimental.rst#L1" class="link-seesrc" target="_blank" >Edit</a>

  <div class="nine columns" id="content">
  <div id="tocRoot"></div>
  
  <p class="module-desc"><table class="docinfo" frame="void" rules="none"><col class="docinfo-name" /><col class="docinfo-content" /><tbody valign="top"><tr><th class="docinfo-name">Authors:</th><td> Andreas Rumpf</td></tr>
<tr><th class="docinfo-name">Version:</th><td> 1.5.1</td></tr>
</tbody></table>
<h1><a class="toc-backref" id="about-this-document" href="#about-this-document">About this document</a></h1><p>This document describes features of Nim that are to be considered experimental. Some of these are not covered by the <tt class="docutils literal"><span class="pre">.experimental</span></tt> pragma or <tt class="docutils literal"><span class="pre">--experimental</span></tt> switch because they are already behind a special syntax and one may want to use Nim libraries using these features without using them oneself.</p>
<p><strong>Note</strong>: Unless otherwise indicated, these features are not to be removed, but refined and overhauled.</p>

<h1><a class="toc-backref" id="package-level-objects" href="#package-level-objects">Package level objects</a></h1><p>Every Nim module resides in a (nimble) package. An object type can be attached to the package it resides in. If that is done, the type can be referenced from other modules as an <span id="incomplete_1">incomplete</span> object type. This feature allows to break up recursive type dependencies across module boundaries. Incomplete object types are always passed <tt class="docutils literal"><span class="pre">byref</span></tt> and can only be used in pointer like contexts (<tt class="docutils literal"><span class="pre">var/ref/ptr IncompleteObject</span></tt>) in general since the compiler does not yet know the size of the object. To complete an incomplete object the <tt class="docutils literal"><span class="pre">package</span></tt> pragma has to be used. <tt class="docutils literal"><span class="pre">package</span></tt> implies <tt class="docutils literal"><span class="pre">byref</span></tt>.</p>
<p>As long as a type <tt class="docutils literal"><span class="pre">T</span></tt> is incomplete, neither <tt class="docutils literal"><span class="pre">sizeof(T)</span></tt> nor runtime type information for <tt class="docutils literal"><span class="pre">T</span></tt> is available.</p>
<p>Example:</p>
<pre class="listing"><span class="Comment"># module A (in an arbitrary package)</span>
<span class="Keyword">type</span>
  <span class="Identifier">Pack</span><span class="Operator">.</span><span class="Identifier">SomeObject</span> <span class="Operator">=</span> <span class="Keyword">object</span> <span class="Comment">## declare as incomplete object of package 'Pack'</span>
  <span class="Identifier">Triple</span> <span class="Operator">=</span> <span class="Keyword">object</span>
    <span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">,</span> <span class="Identifier">c</span><span class="Punctuation">:</span> <span class="Keyword">ref</span> <span class="Identifier">SomeObject</span> <span class="Comment">## pointers to incomplete objects are allowed</span>

<span class="Comment">## Incomplete objects can be used as parameters:</span>
<span class="Keyword">proc</span> <span class="Identifier">myproc</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">SomeObject</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Keyword">discard</span></pre><pre class="listing"><span class="Comment"># module B (in package &quot;Pack&quot;)</span>
<span class="Keyword">type</span>
  <span class="Identifier">SomeObject</span><span class="Operator">*</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">package</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span> <span class="Keyword">object</span> <span class="Comment">## Use 'package' to complete the object</span>
    <span class="Identifier">s</span><span class="Punctuation">,</span> <span class="Identifier">t</span><span class="Punctuation">:</span> <span class="Identifier">string</span>
    <span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">int</span></pre>
<h1><a class="toc-backref" id="void-type" href="#void-type">Void type</a></h1><p>The <tt class="docutils literal"><span class="pre">void</span></tt> type denotes the absence of any type. Parameters of type <tt class="docutils literal"><span class="pre">void</span></tt> are treated as non-existent, <tt class="docutils literal"><span class="pre">void</span></tt> as a return type means that the procedure does not return a value:</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">nothing</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">void</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">void</span> <span class="Operator">=</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;ha&quot;</span>

<span class="Identifier">nothing</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Comment"># writes &quot;ha&quot; to stdout</span></pre><p>The <tt class="docutils literal"><span class="pre">void</span></tt> type is particularly useful for generic code:</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">callProc</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">p</span><span class="Punctuation">:</span> <span class="Keyword">proc</span> <span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">T</span><span class="Punctuation">)</span><span class="Punctuation">,</span> <span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">T</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">when</span> <span class="Identifier">T</span> <span class="Keyword">is</span> <span class="Identifier">void</span><span class="Punctuation">:</span>
    <span class="Identifier">p</span><span class="Punctuation">(</span><span class="Punctuation">)</span>
  <span class="Keyword">else</span><span class="Punctuation">:</span>
    <span class="Identifier">p</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span>

<span class="Keyword">proc</span> <span class="Identifier">intProc</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Keyword">discard</span>
<span class="Keyword">proc</span> <span class="Identifier">emptyProc</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Keyword">discard</span>

<span class="Identifier">callProc</span><span class="Punctuation">[</span><span class="Identifier">int</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">intProc</span><span class="Punctuation">,</span> <span class="DecNumber">12</span><span class="Punctuation">)</span>
<span class="Identifier">callProc</span><span class="Punctuation">[</span><span class="Identifier">void</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">emptyProc</span><span class="Punctuation">)</span></pre><p>However, a <tt class="docutils literal"><span class="pre">void</span></tt> type cannot be inferred in generic code:</p>
<pre class="listing"><span class="Identifier">callProc</span><span class="Punctuation">(</span><span class="Identifier">emptyProc</span><span class="Punctuation">)</span>
<span class="Comment"># Error: type mismatch: got (proc ())</span>
<span class="Comment"># but expected one of:</span>
<span class="Comment"># callProc(p: proc (T), x: T)</span></pre><p>The <tt class="docutils literal"><span class="pre">void</span></tt> type is only valid for parameters and return types; other symbols cannot have the type <tt class="docutils literal"><span class="pre">void</span></tt>.</p>

<h1><a class="toc-backref" id="covariance" href="#covariance">Covariance</a></h1><p>Covariance in Nim can be introduced only through pointer-like types such as <tt class="docutils literal"><span class="pre">ptr</span></tt> and <tt class="docutils literal"><span class="pre">ref</span></tt>. Sequence, Array and OpenArray types, instantiated with pointer-like types will be considered covariant if and only if they are also immutable. The introduction of a <tt class="docutils literal"><span class="pre">var</span></tt> modifier or additional <tt class="docutils literal"><span class="pre">ptr</span></tt> or <tt class="docutils literal"><span class="pre">ref</span></tt> indirections would result in invariant treatment of these types.</p>
<p><tt class="docutils literal"><span class="pre">proc</span></tt> types are currently always invariant, but future versions of Nim may relax this rule.</p>
<p>User-defined generic types may also be covariant with respect to some of their parameters. By default, all generic params are considered invariant, but you may choose the apply the prefix modifier <tt class="docutils literal"><span class="pre">in</span></tt> to a parameter to make it contravariant or <tt class="docutils literal"><span class="pre">out</span></tt> to make it covariant:</p>
<pre class="listing"><span class="Keyword">type</span>
  <span class="Identifier">AnnotatedPtr</span><span class="Punctuation">[</span><span class="Keyword">out</span> <span class="Identifier">T</span><span class="Punctuation">]</span> <span class="Operator">=</span>
    <span class="Identifier">metadata</span><span class="Punctuation">:</span> <span class="Identifier">MyTypeInfo</span>
    <span class="Identifier">p</span><span class="Punctuation">:</span> <span class="Keyword">ref</span> <span class="Identifier">T</span>
  
  <span class="Identifier">RingBuffer</span><span class="Punctuation">[</span><span class="Keyword">out</span> <span class="Identifier">T</span><span class="Punctuation">]</span> <span class="Operator">=</span>
    <span class="Identifier">startPos</span><span class="Punctuation">:</span> <span class="Identifier">int</span>
    <span class="Identifier">data</span><span class="Punctuation">:</span> <span class="Identifier">seq</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span>
  
  <span class="Identifier">Action</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">importcpp</span><span class="Punctuation">:</span> <span class="StringLit">&quot;std::function&lt;void ('0)&gt;&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Punctuation">[</span><span class="Keyword">in</span> <span class="Identifier">T</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Keyword">object</span></pre><p>When the designated generic parameter is used to instantiate a pointer-like type as in the case of <tt class="docutils literal"><span class="pre">AnnotatedPtr</span></tt> above, the resulting generic type will also have pointer-like covariance:</p>
<pre class="listing"><span class="Keyword">type</span>
  <span class="Identifier">GuiWidget</span> <span class="Operator">=</span> <span class="Keyword">object</span> <span class="Keyword">of</span> <span class="Identifier">RootObj</span>
  <span class="Identifier">Button</span> <span class="Operator">=</span> <span class="Keyword">object</span> <span class="Keyword">of</span> <span class="Identifier">GuiWidget</span>
  <span class="Identifier">ComboBox</span> <span class="Operator">=</span> <span class="Keyword">object</span> <span class="Keyword">of</span> <span class="Identifier">GuiWidget</span>

<span class="Keyword">var</span>
  <span class="Identifier">widgetPtr</span><span class="Punctuation">:</span> <span class="Identifier">AnnotatedPtr</span><span class="Punctuation">[</span><span class="Identifier">GuiWidget</span><span class="Punctuation">]</span>
  <span class="Identifier">buttonPtr</span><span class="Punctuation">:</span> <span class="Identifier">AnnotatedPtr</span><span class="Punctuation">[</span><span class="Identifier">Button</span><span class="Punctuation">]</span>

<span class="Operator">...</span>

<span class="Keyword">proc</span> <span class="Identifier">drawWidget</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">AnnotatedPtr</span><span class="Punctuation">[</span><span class="Identifier">GuiWidget</span><span class="Punctuation">]</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Operator">...</span>

<span class="Comment"># you can call procs expecting base types by supplying a derived type</span>
<span class="Identifier">drawWidget</span><span class="Punctuation">(</span><span class="Identifier">buttonPtr</span><span class="Punctuation">)</span>

<span class="Comment"># and you can convert more-specific pointer types to more general ones</span>
<span class="Identifier">widgetPtr</span> <span class="Operator">=</span> <span class="Identifier">buttonPtr</span></pre><p>Just like with regular pointers, covariance will be enabled only for immutable values:</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">makeComboBox</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Keyword">var</span> <span class="Identifier">AnnotatedPtr</span><span class="Punctuation">[</span><span class="Identifier">GuiWidget</span><span class="Punctuation">]</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Identifier">x</span><span class="Operator">.</span><span class="Identifier">p</span> <span class="Operator">=</span> <span class="Identifier">new</span><span class="Punctuation">(</span><span class="Identifier">ComboBox</span><span class="Punctuation">)</span>

<span class="Identifier">makeComboBox</span><span class="Punctuation">(</span><span class="Identifier">buttonPtr</span><span class="Punctuation">)</span> <span class="Comment"># Error, AnnotatedPtr[Button] cannot be modified</span>
                        <span class="Comment"># to point to a ComboBox</span></pre><p>On the other hand, in the <tt class="docutils literal"><span class="pre">RingBuffer</span></tt> example above, the designated generic param is used to instantiate the non-pointer <tt class="docutils literal"><span class="pre">seq</span></tt> type, which means that the resulting generic type will have covariance that mimics an array or sequence (i.e. it will be covariant only when instantiated with <tt class="docutils literal"><span class="pre">ptr</span></tt> and <tt class="docutils literal"><span class="pre">ref</span></tt> types):</p>
<pre class="listing"><span class="Keyword">type</span>
  <span class="Identifier">Base</span> <span class="Operator">=</span> <span class="Keyword">object</span> <span class="Keyword">of</span> <span class="Identifier">RootObj</span>
  <span class="Identifier">Derived</span> <span class="Operator">=</span> <span class="Keyword">object</span> <span class="Keyword">of</span> <span class="Identifier">Base</span>

<span class="Keyword">proc</span> <span class="Identifier">consumeBaseValues</span><span class="Punctuation">(</span><span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">RingBuffer</span><span class="Punctuation">[</span><span class="Identifier">Base</span><span class="Punctuation">]</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Operator">...</span>

<span class="Keyword">var</span> <span class="Identifier">derivedValues</span><span class="Punctuation">:</span> <span class="Identifier">RingBuffer</span><span class="Punctuation">[</span><span class="Identifier">Derived</span><span class="Punctuation">]</span>

<span class="Identifier">consumeBaseValues</span><span class="Punctuation">(</span><span class="Identifier">derivedValues</span><span class="Punctuation">)</span> <span class="Comment"># Error, Base and Derived values may differ</span>
                                 <span class="Comment"># in size</span>

<span class="Keyword">proc</span> <span class="Identifier">consumeBasePointers</span><span class="Punctuation">(</span><span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">RingBuffer</span><span class="Punctuation">[</span><span class="Keyword">ptr</span> <span class="Identifier">Base</span><span class="Punctuation">]</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Operator">...</span>

<span class="Keyword">var</span> <span class="Identifier">derivedPointers</span><span class="Punctuation">:</span> <span class="Identifier">RingBuffer</span><span class="Punctuation">[</span><span class="Keyword">ptr</span> <span class="Identifier">Derived</span><span class="Punctuation">]</span>

<span class="Identifier">consumeBaseValues</span><span class="Punctuation">(</span><span class="Identifier">derivedPointers</span><span class="Punctuation">)</span> <span class="Comment"># This is legal</span></pre><p>Please note that Nim will treat the user-defined pointer-like types as proper alternatives to the built-in pointer types. That is, types such as <tt class="docutils literal"><span class="pre">seq[AnnotatedPtr[T]]</span></tt> or <tt class="docutils literal"><span class="pre">RingBuffer[AnnotatedPtr[T]]</span></tt> will also be considered covariant and you can create new pointer-like types by instantiating other user-defined pointer-like types.</p>
<p>The contravariant parameters introduced with the <tt class="docutils literal"><span class="pre">in</span></tt> modifier are currently useful only when interfacing with imported types having such semantics.</p>

<h1><a class="toc-backref" id="automatic-dereferencing" href="#automatic-dereferencing">Automatic dereferencing</a></h1><p>Automatic dereferencing is performed for the first argument of a routine call. This feature has to be only enabled via <tt class="docutils literal"><span class="pre">{.experimental: &quot;implicitDeref&quot;.}</span></tt>:</p>
<pre class="listing"><span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">experimental</span><span class="Punctuation">:</span> <span class="StringLit">&quot;implicitDeref&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span>

<span class="Keyword">proc</span> <span class="Identifier">depth</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">NodeObj</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span> <span class="Operator">...</span>

<span class="Keyword">var</span>
  <span class="Identifier">n</span><span class="Punctuation">:</span> <span class="Identifier">Node</span>
<span class="Identifier">new</span><span class="Punctuation">(</span><span class="Identifier">n</span><span class="Punctuation">)</span>
<span class="Identifier">echo</span> <span class="Identifier">n</span><span class="Operator">.</span><span class="Identifier">depth</span>
<span class="Comment"># no need to write n[].depth either</span></pre>
<h1><a class="toc-backref" id="code-reordering" href="#code-reordering">Code reordering</a></h1><p>The code reordering feature can implicitly rearrange procedure, template, and macro definitions along with variable declarations and initializations at the top level scope so that, to a large extent, a programmer should not have to worry about ordering definitions correctly or be forced to use forward declarations to preface definitions inside a module.</p>
<p>Example:</p>
<pre class="listing"><span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">experimental</span><span class="Punctuation">:</span> <span class="StringLit">&quot;codeReordering&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span>

<span class="Keyword">proc</span> <span class="Identifier">foo</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Identifier">bar</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span>

<span class="Keyword">proc</span> <span class="Identifier">bar</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Identifier">echo</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span>

<span class="Identifier">foo</span><span class="Punctuation">(</span><span class="DecNumber">10</span><span class="Punctuation">)</span></pre><p>Variables can also be reordered as well. Variables that are <em>initialized</em> (i.e. variables that have their declaration and assignment combined in a single statement) can have their entire initialization statement reordered. Be wary of what code is executed at the top level:</p>
<pre class="listing"><span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">experimental</span><span class="Punctuation">:</span> <span class="StringLit">&quot;codeReordering&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span>

<span class="Keyword">proc</span> <span class="Identifier">a</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Identifier">echo</span><span class="Punctuation">(</span><span class="Identifier">foo</span><span class="Punctuation">)</span>

<span class="Keyword">var</span> <span class="Identifier">foo</span> <span class="Operator">=</span> <span class="DecNumber">5</span>

<span class="Identifier">a</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Comment"># outputs: &quot;5&quot;</span></pre><p>It is important to note that reordering <em>only</em> works for symbols at top level scope. Therefore, the following will <em>fail to compile:</em></p>
<pre class="listing"><span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">experimental</span><span class="Punctuation">:</span> <span class="StringLit">&quot;codeReordering&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span>

<span class="Keyword">proc</span> <span class="Identifier">a</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Identifier">b</span><span class="Punctuation">(</span><span class="Punctuation">)</span>
  <span class="Keyword">proc</span> <span class="Identifier">b</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Operator">=</span>
    <span class="Identifier">echo</span><span class="Punctuation">(</span><span class="StringLit">&quot;Hello!&quot;</span><span class="Punctuation">)</span>

<span class="Identifier">a</span><span class="Punctuation">(</span><span class="Punctuation">)</span></pre>
<h1><a class="toc-backref" id="named-argument-overloading" href="#named-argument-overloading">Named argument overloading</a></h1><p>Routines with the same type signature can be called differently if a parameter has different names. This does not need an <tt class="docutils literal"><span class="pre">experimental</span></tt> switch, but is an unstable feature.</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">foo</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;Using x: &quot;</span><span class="Punctuation">,</span> <span class="Identifier">x</span>
<span class="Keyword">proc</span> <span class="Identifier">foo</span><span class="Punctuation">(</span><span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;Using y: &quot;</span><span class="Punctuation">,</span> <span class="Identifier">y</span>

<span class="Identifier">foo</span><span class="Punctuation">(</span><span class="Identifier">x</span> <span class="Operator">=</span> <span class="DecNumber">2</span><span class="Punctuation">)</span>
<span class="Comment"># Using x: 2</span>
<span class="Identifier">foo</span><span class="Punctuation">(</span><span class="Identifier">y</span> <span class="Operator">=</span> <span class="DecNumber">2</span><span class="Punctuation">)</span>
<span class="Comment"># Using y: 2</span></pre>
<h1><a class="toc-backref" id="do-notation" href="#do-notation">Do notation</a></h1><p>As a special more convenient notation, proc expressions involved in procedure calls can use the <tt class="docutils literal"><span class="pre">do</span></tt> keyword:</p>
<pre class="listing"><span class="Identifier">sort</span><span class="Punctuation">(</span><span class="Identifier">cities</span><span class="Punctuation">)</span> <span class="Keyword">do</span> <span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">,</span><span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">)</span> <span class="Operator">-&gt;</span> <span class="Identifier">int</span><span class="Punctuation">:</span>
  <span class="Identifier">cmp</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Operator">.</span><span class="Identifier">len</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Operator">.</span><span class="Identifier">len</span><span class="Punctuation">)</span>

<span class="Comment"># Less parenthesis using the method plus command syntax:</span>
<span class="Identifier">cities</span> <span class="Operator">=</span> <span class="Identifier">cities</span><span class="Operator">.</span><span class="Identifier">map</span> <span class="Keyword">do</span> <span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span><span class="Identifier">string</span><span class="Punctuation">)</span> <span class="Operator">-&gt;</span> <span class="Identifier">string</span><span class="Punctuation">:</span>
  <span class="StringLit">&quot;City of &quot;</span> <span class="Operator">&amp;</span> <span class="Identifier">x</span>

<span class="Comment"># In macros, the do notation is often used for quasi-quoting</span>
<span class="Identifier">macroResults</span><span class="Operator">.</span><span class="Identifier">add</span> <span class="Identifier">quote</span> <span class="Keyword">do</span><span class="Punctuation">:</span>
  <span class="Keyword">if</span> <span class="Keyword">not</span> <span class="Punctuation">`</span><span class="Identifier">ex</span><span class="Punctuation">`</span><span class="Punctuation">:</span>
    <span class="Identifier">echo</span> <span class="Punctuation">`</span><span class="Identifier">info</span><span class="Punctuation">`</span><span class="Punctuation">,</span> <span class="StringLit">&quot;: Check failed: &quot;</span><span class="Punctuation">,</span> <span class="Punctuation">`</span><span class="Identifier">expString</span><span class="Punctuation">`</span></pre><p><tt class="docutils literal"><span class="pre">do</span></tt> is written after the parentheses enclosing the regular proc params. The proc expression represented by the do block is appended to them. In calls using the command syntax, the do block will bind to the immediately preceding expression, transforming it in a call.</p>
<p><tt class="docutils literal"><span class="pre">do</span></tt> with parentheses is an anonymous <tt class="docutils literal"><span class="pre">proc</span></tt>; however a <tt class="docutils literal"><span class="pre">do</span></tt> without parentheses is just a block of code. The <tt class="docutils literal"><span class="pre">do</span></tt> notation can be used to pass multiple blocks to a macro:</p>
<pre class="listing"><span class="Keyword">macro</span> <span class="Identifier">performWithUndo</span><span class="Punctuation">(</span><span class="Identifier">task</span><span class="Punctuation">,</span> <span class="Identifier">undo</span><span class="Punctuation">:</span> <span class="Identifier">untyped</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Operator">...</span>

<span class="Identifier">performWithUndo</span> <span class="Keyword">do</span><span class="Punctuation">:</span>
  <span class="Comment"># multiple-line block of code</span>
  <span class="Comment"># to perform the task</span>
<span class="Keyword">do</span><span class="Punctuation">:</span>
  <span class="Comment"># code to undo it</span></pre>
<h1><a class="toc-backref" id="special-operators" href="#special-operators">Special Operators</a></h1>
<h2><a class="toc-backref" id="special-operators-dot-operators" href="#special-operators-dot-operators">dot operators</a></h2><p><strong>Note</strong>: Dot operators are still experimental and so need to be enabled via <tt class="docutils literal"><span class="pre">{.experimental: &quot;dotOperators&quot;.}</span></tt>.</p>
<p>Nim offers a special family of dot operators that can be used to intercept and rewrite proc call and field access attempts, referring to previously undeclared symbol names. They can be used to provide a fluent interface to objects lying outside the static confines of the type system such as values from dynamic scripting languages or dynamic file formats such as JSON or XML.</p>
<p>When Nim encounters an expression that cannot be resolved by the standard overload resolution rules, the current scope will be searched for a dot operator that can be matched against a re-written form of the expression, where the unknown field or proc name is passed to an <tt class="docutils literal"><span class="pre">untyped</span></tt> parameter:</p>
<pre class="listing"><span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">b</span> <span class="Comment"># becomes `.`(a, b)</span>
<span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">b</span><span class="Punctuation">(</span><span class="Identifier">c</span><span class="Punctuation">,</span> <span class="Identifier">d</span><span class="Punctuation">)</span> <span class="Comment"># becomes `.`(a, b, c, d)</span></pre><p>The matched dot operators can be symbols of any callable kind (procs, templates and macros), depending on the desired effect:</p>
<pre class="listing"><span class="Keyword">template</span> <span class="Punctuation">`</span><span class="Operator">.</span><span class="Punctuation">`</span> <span class="Punctuation">(</span><span class="Identifier">js</span><span class="Punctuation">:</span> <span class="Identifier">PJsonNode</span><span class="Punctuation">,</span> <span class="Identifier">field</span><span class="Punctuation">:</span> <span class="Identifier">untyped</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">JSON</span> <span class="Operator">=</span> <span class="Identifier">js</span><span class="Punctuation">[</span><span class="Identifier">astToStr</span><span class="Punctuation">(</span><span class="Identifier">field</span><span class="Punctuation">)</span><span class="Punctuation">]</span>

<span class="Keyword">var</span> <span class="Identifier">js</span> <span class="Operator">=</span> <span class="Identifier">parseJson</span><span class="Punctuation">(</span><span class="StringLit">&quot;{ x: 1, y: 2}&quot;</span><span class="Punctuation">)</span>
<span class="Identifier">echo</span> <span class="Identifier">js</span><span class="Operator">.</span><span class="Identifier">x</span> <span class="Comment"># outputs 1</span>
<span class="Identifier">echo</span> <span class="Identifier">js</span><span class="Operator">.</span><span class="Identifier">y</span> <span class="Comment"># outputs 2</span></pre><p>The following dot operators are available:</p>

<h2><a class="toc-backref" id="special-operators-operator-dot" href="#special-operators-operator-dot">operator <tt class="docutils literal"><span class="pre">.</span></tt></a></h2><p>This operator will be matched against both field accesses and method calls.</p>

<h2><a class="toc-backref" id="special-operators-operator-dot" href="#special-operators-operator-dot">operator <tt class="docutils literal"><span class="pre">.()</span></tt></a></h2><p>This operator will be matched exclusively against method calls. It has higher precedence than the <tt class="docutils literal"><span class="pre">.</span></tt> operator and this allows one to handle expressions like <tt class="docutils literal"><span class="pre">x.y</span></tt> and <tt class="docutils literal"><span class="pre">x.y()</span></tt> differently if one is interfacing with a scripting language for example.</p>

<h2><a class="toc-backref" id="special-operators-operator-doteq" href="#special-operators-operator-doteq">operator <tt class="docutils literal"><span class="pre">.=</span></tt></a></h2><p>This operator will be matched against assignments to missing fields.</p>
<pre class="listing"><span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">b</span> <span class="Operator">=</span> <span class="Identifier">c</span> <span class="Comment"># becomes `.=`(a, b, c)</span></pre>
<h1><a class="toc-backref" id="not-nil-annotation" href="#not-nil-annotation">Not nil annotation</a></h1><p><strong>Note:</strong> This is an experimental feature. It can be enabled with <tt class="docutils literal"><span class="pre">{.experimental: &quot;notnil&quot;}</span></tt>.</p>
<p>All types for which <tt class="docutils literal"><span class="pre">nil</span></tt> is a valid value can be annotated with the <tt class="docutils literal"><span class="pre">not nil</span></tt> annotation to exclude <tt class="docutils literal"><span class="pre">nil</span></tt> as a valid value:</p>
<pre class="listing"><span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">experimental</span><span class="Punctuation">:</span> <span class="StringLit">&quot;notnil&quot;</span><span class="Punctuation">}</span>

<span class="Keyword">type</span>
  <span class="Identifier">PObject</span> <span class="Operator">=</span> <span class="Keyword">ref</span> <span class="Identifier">TObj</span> <span class="Keyword">not</span> <span class="Keyword">nil</span>
  <span class="Identifier">TProc</span> <span class="Operator">=</span> <span class="Punctuation">(</span><span class="Keyword">proc</span> <span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">)</span> <span class="Keyword">not</span> <span class="Keyword">nil</span>

<span class="Keyword">proc</span> <span class="Identifier">p</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">PObject</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;not nil&quot;</span>

<span class="Comment"># compiler catches this:</span>
<span class="Identifier">p</span><span class="Punctuation">(</span><span class="Keyword">nil</span><span class="Punctuation">)</span>

<span class="Comment"># and also this:</span>
<span class="Keyword">var</span> <span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">PObject</span>
<span class="Identifier">p</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span></pre><p>The compiler ensures that every code path initializes variables which contain non-nilable pointers. The details of this analysis are still to be specified here.</p>

<h1><a class="toc-backref" id="concepts" href="#concepts">Concepts</a></h1><p>Concepts, also known as &quot;user-defined type classes&quot;, are used to specify an arbitrary set of requirements that the matched type must satisfy.</p>
<p>Concepts are written in the following form:</p>
<pre class="listing"><span class="Keyword">type</span>
  <span class="Identifier">Comparable</span> <span class="Operator">=</span> <span class="Keyword">concept</span> <span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span>
    <span class="Punctuation">(</span><span class="Identifier">x</span> <span class="Operator">&lt;</span> <span class="Identifier">y</span><span class="Punctuation">)</span> <span class="Keyword">is</span> <span class="Identifier">bool</span>
  
  <span class="Identifier">Stack</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Keyword">concept</span> <span class="Identifier">s</span><span class="Punctuation">,</span> <span class="Keyword">var</span> <span class="Identifier">v</span>
    <span class="Identifier">s</span><span class="Operator">.</span><span class="Identifier">pop</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Keyword">is</span> <span class="Identifier">T</span>
    <span class="Identifier">v</span><span class="Operator">.</span><span class="Identifier">push</span><span class="Punctuation">(</span><span class="Identifier">T</span><span class="Punctuation">)</span>
    
    <span class="Identifier">s</span><span class="Operator">.</span><span class="Identifier">len</span> <span class="Keyword">is</span> <span class="Identifier">Ordinal</span>
    
    <span class="Keyword">for</span> <span class="Identifier">value</span> <span class="Keyword">in</span> <span class="Identifier">s</span><span class="Punctuation">:</span>
      <span class="Identifier">value</span> <span class="Keyword">is</span> <span class="Identifier">T</span></pre><p>The concept is a match if:</p>
<ol class="simple"><li>all of the expressions within the body can be compiled for the tested type</li>
<li>all statically evaluable boolean expressions in the body must be true</li>
</ol>
<p>The identifiers following the <tt class="docutils literal"><span class="pre">concept</span></tt> keyword represent instances of the currently matched type. You can apply any of the standard type modifiers such as <tt class="docutils literal"><span class="pre">var</span></tt>, <tt class="docutils literal"><span class="pre">ref</span></tt>, <tt class="docutils literal"><span class="pre">ptr</span></tt> and <tt class="docutils literal"><span class="pre">static</span></tt> to denote a more specific type of instance. You can also apply the <tt class="docutils literal"><span class="pre">type</span></tt> modifier to create a named instance of the type itself:</p>
<pre class="listing"><span class="Keyword">type</span>
  <span class="Identifier">MyConcept</span> <span class="Operator">=</span> <span class="Keyword">concept</span> <span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Keyword">var</span> <span class="Identifier">v</span><span class="Punctuation">,</span> <span class="Keyword">ref</span> <span class="Identifier">r</span><span class="Punctuation">,</span> <span class="Keyword">ptr</span> <span class="Identifier">p</span><span class="Punctuation">,</span> <span class="Keyword">static</span> <span class="Identifier">s</span><span class="Punctuation">,</span> <span class="Keyword">type</span> <span class="Identifier">T</span>
    <span class="Operator">...</span></pre><p>Within the concept body, types can appear in positions where ordinary values and parameters are expected. This provides a more convenient way to check for the presence of callable symbols with specific signatures:</p>
<pre class="listing"><span class="Keyword">type</span>
  <span class="Identifier">OutputStream</span> <span class="Operator">=</span> <span class="Keyword">concept</span> <span class="Keyword">var</span> <span class="Identifier">s</span>
    <span class="Identifier">s</span><span class="Operator">.</span><span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">string</span><span class="Punctuation">)</span></pre><p>In order to check for symbols accepting <tt class="docutils literal"><span class="pre">type</span></tt> params, you must prefix the type with the explicit <tt class="docutils literal"><span class="pre">type</span></tt> modifier. The named instance of the type, following the <tt class="docutils literal"><span class="pre">concept</span></tt> keyword is also considered to have the explicit modifier and will be matched only as a type.</p>
<pre class="listing"><span class="Keyword">type</span>
  <span class="Comment"># Let's imagine a user-defined casting framework with operators</span>
  <span class="Comment"># such as `val.to(string)` and `val.to(JSonValue)`. We can test</span>
  <span class="Comment"># for these with the following concept:</span>
  <span class="Identifier">MyCastables</span> <span class="Operator">=</span> <span class="Keyword">concept</span> <span class="Identifier">x</span>
    <span class="Identifier">x</span><span class="Operator">.</span><span class="Identifier">to</span><span class="Punctuation">(</span><span class="Keyword">type</span> <span class="Identifier">string</span><span class="Punctuation">)</span>
    <span class="Identifier">x</span><span class="Operator">.</span><span class="Identifier">to</span><span class="Punctuation">(</span><span class="Keyword">type</span> <span class="Identifier">JSonValue</span><span class="Punctuation">)</span>
  
  <span class="Comment"># Let's define a couple of concepts, known from Algebra:</span>
  <span class="Identifier">AdditiveMonoid</span><span class="Operator">*</span> <span class="Operator">=</span> <span class="Keyword">concept</span> <span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">,</span> <span class="Keyword">type</span> <span class="Identifier">T</span>
    <span class="Identifier">x</span> <span class="Operator">+</span> <span class="Identifier">y</span> <span class="Keyword">is</span> <span class="Identifier">T</span>
    <span class="Identifier">T</span><span class="Operator">.</span><span class="Identifier">zero</span> <span class="Keyword">is</span> <span class="Identifier">T</span> <span class="Comment"># require a proc such as `int.zero` or 'Position.zero'</span>
  
  <span class="Identifier">AdditiveGroup</span><span class="Operator">*</span> <span class="Operator">=</span> <span class="Keyword">concept</span> <span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">,</span> <span class="Keyword">type</span> <span class="Identifier">T</span>
    <span class="Identifier">x</span> <span class="Keyword">is</span> <span class="Identifier">AdditiveMonoid</span>
    <span class="Operator">-</span><span class="Identifier">x</span> <span class="Keyword">is</span> <span class="Identifier">T</span>
    <span class="Identifier">x</span> <span class="Operator">-</span> <span class="Identifier">y</span> <span class="Keyword">is</span> <span class="Identifier">T</span></pre><p>Please note that the <tt class="docutils literal"><span class="pre">is</span></tt> operator allows one to easily verify the precise type signatures of the required operations, but since type inference and default parameters are still applied in the concept body, it's also possible to describe usage protocols that do not reveal implementation details.</p>
<p>Much like generics, concepts are instantiated exactly once for each tested type and any static code included within the body is executed only once.</p>

<h2><a class="toc-backref" id="concepts-concept-diagnostics" href="#concepts-concept-diagnostics">Concept diagnostics</a></h2><p>By default, the compiler will report the matching errors in concepts only when no other overload can be selected and a normal compilation error is produced. When you need to understand why the compiler is not matching a particular concept and, as a result, a wrong overload is selected, you can apply the <tt class="docutils literal"><span class="pre">explain</span></tt> pragma to either the concept body or a particular call-site.</p>
<pre class="listing"><span class="Keyword">type</span>
  <span class="Identifier">MyConcept</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">explain</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span> <span class="Keyword">concept</span> <span class="Operator">...</span>

<span class="Identifier">overloadedProc</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">,</span> <span class="Identifier">z</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">explain</span><span class="Operator">.</span><span class="Punctuation">}</span></pre><p>This will provide Hints in the compiler output either every time the concept is not matched or only on the particular call-site.</p>

<h2><a class="toc-backref" id="concepts-generic-concepts-and-type-binding-rules" href="#concepts-generic-concepts-and-type-binding-rules">Generic concepts and type binding rules</a></h2><p>The concept types can be parametric just like the regular generic types:</p>
<pre class="listing"><span class="Comment">### matrixalgo.nim</span>

<span class="Keyword">import</span> <span class="Identifier">typetraits</span>

<span class="Keyword">type</span>
  <span class="Identifier">AnyMatrix</span><span class="Operator">*</span><span class="Punctuation">[</span><span class="Identifier">R</span><span class="Punctuation">,</span> <span class="Identifier">C</span><span class="Punctuation">:</span> <span class="Keyword">static</span> <span class="Identifier">int</span><span class="Punctuation">;</span> <span class="Identifier">T</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Keyword">concept</span> <span class="Identifier">m</span><span class="Punctuation">,</span> <span class="Keyword">var</span> <span class="Identifier">mvar</span><span class="Punctuation">,</span> <span class="Keyword">type</span> <span class="Identifier">M</span>
    <span class="Identifier">M</span><span class="Operator">.</span><span class="Identifier">ValueType</span> <span class="Keyword">is</span> <span class="Identifier">T</span>
    <span class="Identifier">M</span><span class="Operator">.</span><span class="Identifier">Rows</span> <span class="Operator">==</span> <span class="Identifier">R</span>
    <span class="Identifier">M</span><span class="Operator">.</span><span class="Identifier">Cols</span> <span class="Operator">==</span> <span class="Identifier">C</span>
    
    <span class="Identifier">m</span><span class="Punctuation">[</span><span class="Identifier">int</span><span class="Punctuation">,</span> <span class="Identifier">int</span><span class="Punctuation">]</span> <span class="Keyword">is</span> <span class="Identifier">T</span>
    <span class="Identifier">mvar</span><span class="Punctuation">[</span><span class="Identifier">int</span><span class="Punctuation">,</span> <span class="Identifier">int</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Identifier">T</span>
    
    <span class="Keyword">type</span> <span class="Identifier">TransposedType</span> <span class="Operator">=</span> <span class="Identifier">stripGenericParams</span><span class="Punctuation">(</span><span class="Identifier">M</span><span class="Punctuation">)</span><span class="Punctuation">[</span><span class="Identifier">C</span><span class="Punctuation">,</span> <span class="Identifier">R</span><span class="Punctuation">,</span> <span class="Identifier">T</span><span class="Punctuation">]</span>
  
  <span class="Identifier">AnySquareMatrix</span><span class="Operator">*</span><span class="Punctuation">[</span><span class="Identifier">N</span><span class="Punctuation">:</span> <span class="Keyword">static</span> <span class="Identifier">int</span><span class="Punctuation">,</span> <span class="Identifier">T</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Identifier">AnyMatrix</span><span class="Punctuation">[</span><span class="Identifier">N</span><span class="Punctuation">,</span> <span class="Identifier">N</span><span class="Punctuation">,</span> <span class="Identifier">T</span><span class="Punctuation">]</span>
  
  <span class="Identifier">AnyTransform3D</span><span class="Operator">*</span> <span class="Operator">=</span> <span class="Identifier">AnyMatrix</span><span class="Punctuation">[</span><span class="DecNumber">4</span><span class="Punctuation">,</span> <span class="DecNumber">4</span><span class="Punctuation">,</span> <span class="Identifier">float</span><span class="Punctuation">]</span>

<span class="Keyword">proc</span> <span class="Identifier">transposed</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">m</span><span class="Punctuation">:</span> <span class="Identifier">AnyMatrix</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">m</span><span class="Operator">.</span><span class="Identifier">TransposedType</span> <span class="Operator">=</span>
  <span class="Keyword">for</span> <span class="Identifier">r</span> <span class="Keyword">in</span> <span class="DecNumber">0</span> <span class="Operator">..&lt;</span> <span class="Identifier">m</span><span class="Operator">.</span><span class="Identifier">R</span><span class="Punctuation">:</span>
    <span class="Keyword">for</span> <span class="Identifier">c</span> <span class="Keyword">in</span> <span class="DecNumber">0</span> <span class="Operator">..&lt;</span> <span class="Identifier">m</span><span class="Operator">.</span><span class="Identifier">C</span><span class="Punctuation">:</span>
      <span class="Identifier">result</span><span class="Punctuation">[</span><span class="Identifier">r</span><span class="Punctuation">,</span> <span class="Identifier">c</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Identifier">m</span><span class="Punctuation">[</span><span class="Identifier">c</span><span class="Punctuation">,</span> <span class="Identifier">r</span><span class="Punctuation">]</span>

<span class="Keyword">proc</span> <span class="Identifier">determinant</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">m</span><span class="Punctuation">:</span> <span class="Identifier">AnySquareMatrix</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span>
  <span class="Operator">...</span>

<span class="Keyword">proc</span> <span class="Identifier">setPerspectiveProjection</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">m</span><span class="Punctuation">:</span> <span class="Identifier">AnyTransform3D</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Operator">...</span>

<span class="Operator">--------------</span>
<span class="Comment">### matrix.nim</span>

<span class="Keyword">type</span>
  <span class="Identifier">Matrix</span><span class="Operator">*</span><span class="Punctuation">[</span><span class="Identifier">M</span><span class="Punctuation">,</span> <span class="Identifier">N</span><span class="Punctuation">:</span> <span class="Keyword">static</span> <span class="Identifier">int</span><span class="Punctuation">;</span> <span class="Identifier">T</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Keyword">object</span>
    <span class="Identifier">data</span><span class="Punctuation">:</span> <span class="Identifier">array</span><span class="Punctuation">[</span><span class="Identifier">M</span><span class="Operator">*</span><span class="Identifier">N</span><span class="Punctuation">,</span> <span class="Identifier">T</span><span class="Punctuation">]</span>

<span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Punctuation">[</span><span class="Punctuation">]</span><span class="Punctuation">`</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">M</span><span class="Punctuation">:</span> <span class="Identifier">Matrix</span><span class="Punctuation">;</span> <span class="Identifier">m</span><span class="Punctuation">,</span> <span class="Identifier">n</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">M</span><span class="Operator">.</span><span class="Identifier">T</span> <span class="Operator">=</span>
  <span class="Identifier">M</span><span class="Operator">.</span><span class="Identifier">data</span><span class="Punctuation">[</span><span class="Identifier">m</span> <span class="Operator">*</span> <span class="Identifier">M</span><span class="Operator">.</span><span class="Identifier">N</span> <span class="Operator">+</span> <span class="Identifier">n</span><span class="Punctuation">]</span>

<span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Punctuation">[</span><span class="Punctuation">]</span><span class="Operator">=</span><span class="Punctuation">`</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">M</span><span class="Punctuation">:</span> <span class="Keyword">var</span> <span class="Identifier">Matrix</span><span class="Punctuation">;</span> <span class="Identifier">m</span><span class="Punctuation">,</span> <span class="Identifier">n</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">;</span> <span class="Identifier">v</span><span class="Punctuation">:</span> <span class="Identifier">M</span><span class="Operator">.</span><span class="Identifier">T</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Identifier">M</span><span class="Operator">.</span><span class="Identifier">data</span><span class="Punctuation">[</span><span class="Identifier">m</span> <span class="Operator">*</span> <span class="Identifier">M</span><span class="Operator">.</span><span class="Identifier">N</span> <span class="Operator">+</span> <span class="Identifier">n</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Identifier">v</span>

<span class="Comment"># Adapt the Matrix type to the concept's requirements</span>
<span class="Keyword">template</span> <span class="Identifier">Rows</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">M</span><span class="Punctuation">:</span> <span class="Identifier">typedesc</span><span class="Punctuation">[</span><span class="Identifier">Matrix</span><span class="Punctuation">]</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span> <span class="Identifier">M</span><span class="Operator">.</span><span class="Identifier">M</span>
<span class="Keyword">template</span> <span class="Identifier">Cols</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">M</span><span class="Punctuation">:</span> <span class="Identifier">typedesc</span><span class="Punctuation">[</span><span class="Identifier">Matrix</span><span class="Punctuation">]</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span> <span class="Identifier">M</span><span class="Operator">.</span><span class="Identifier">N</span>
<span class="Keyword">template</span> <span class="Identifier">ValueType</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">M</span><span class="Punctuation">:</span> <span class="Identifier">typedesc</span><span class="Punctuation">[</span><span class="Identifier">Matrix</span><span class="Punctuation">]</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">typedesc</span> <span class="Operator">=</span> <span class="Identifier">M</span><span class="Operator">.</span><span class="Identifier">T</span>

<span class="Operator">-------------</span>
<span class="Comment">### usage.nim</span>

<span class="Keyword">import</span> <span class="Identifier">matrix</span><span class="Punctuation">,</span> <span class="Identifier">matrixalgo</span>

<span class="Keyword">var</span>
  <span class="Identifier">m</span><span class="Punctuation">:</span> <span class="Identifier">Matrix</span><span class="Punctuation">[</span><span class="DecNumber">3</span><span class="Punctuation">,</span> <span class="DecNumber">3</span><span class="Punctuation">,</span> <span class="Identifier">int</span><span class="Punctuation">]</span>
  <span class="Identifier">projectionMatrix</span><span class="Punctuation">:</span> <span class="Identifier">Matrix</span><span class="Punctuation">[</span><span class="DecNumber">4</span><span class="Punctuation">,</span> <span class="DecNumber">4</span><span class="Punctuation">,</span> <span class="Identifier">float</span><span class="Punctuation">]</span>

<span class="Identifier">echo</span> <span class="Identifier">m</span><span class="Operator">.</span><span class="Identifier">transposed</span><span class="Operator">.</span><span class="Identifier">determinant</span>
<span class="Identifier">setPerspectiveProjection</span> <span class="Identifier">projectionMatrix</span></pre><p>When the concept type is matched against a concrete type, the unbound type parameters are inferred from the body of the concept in a way that closely resembles the way generic parameters of callable symbols are inferred on call sites.</p>
<p>Unbound types can appear both as params to calls such as <tt class="docutils literal"><span class="pre">s.push(T)</span></tt> and on the right-hand side of the <tt class="docutils literal"><span class="pre">is</span></tt> operator in cases such as <tt class="docutils literal"><span class="pre">x.pop is T</span></tt> and <tt class="docutils literal"><span class="pre">x.data is seq[T]</span></tt>.</p>
<p>Unbound static params will be inferred from expressions involving the <tt class="docutils literal"><span class="pre">==</span></tt> operator and also when types dependent on them are being matched:</p>
<pre class="listing"><span class="Keyword">type</span>
  <span class="Identifier">MatrixReducer</span><span class="Punctuation">[</span><span class="Identifier">M</span><span class="Punctuation">,</span> <span class="Identifier">N</span><span class="Punctuation">:</span> <span class="Keyword">static</span> <span class="Identifier">int</span><span class="Punctuation">;</span> <span class="Identifier">T</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Keyword">concept</span> <span class="Identifier">x</span>
    <span class="Identifier">x</span><span class="Operator">.</span><span class="Identifier">reduce</span><span class="Punctuation">(</span><span class="Identifier">SquareMatrix</span><span class="Punctuation">[</span><span class="Identifier">N</span><span class="Punctuation">,</span> <span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">)</span> <span class="Keyword">is</span> <span class="Identifier">array</span><span class="Punctuation">[</span><span class="Identifier">M</span><span class="Punctuation">,</span> <span class="Identifier">int</span><span class="Punctuation">]</span></pre><p>The Nim compiler includes a simple linear equation solver, allowing it to infer static params in some situations where integer arithmetic is involved.</p>
<p>Just like in regular type classes, Nim discriminates between <tt class="docutils literal"><span class="pre">bind once</span></tt> and <tt class="docutils literal"><span class="pre">bind many</span></tt> types when matching the concept. You can add the <tt class="docutils literal"><span class="pre">distinct</span></tt> modifier to any of the otherwise inferable types to get a type that will be matched without permanently inferring it. This may be useful when you need to match several procs accepting the same wide class of types:</p>
<pre class="listing"><span class="Keyword">type</span>
  <span class="Identifier">Enumerable</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Keyword">concept</span> <span class="Identifier">e</span>
    <span class="Keyword">for</span> <span class="Identifier">v</span> <span class="Keyword">in</span> <span class="Identifier">e</span><span class="Punctuation">:</span>
      <span class="Identifier">v</span> <span class="Keyword">is</span> <span class="Identifier">T</span>

<span class="Keyword">type</span>
  <span class="Identifier">MyConcept</span> <span class="Operator">=</span> <span class="Keyword">concept</span> <span class="Identifier">o</span>
    <span class="Comment"># this could be inferred to a type such as Enumerable[int]</span>
    <span class="Identifier">o</span><span class="Operator">.</span><span class="Identifier">foo</span> <span class="Keyword">is</span> <span class="Keyword">distinct</span> <span class="Identifier">Enumerable</span>
    
    <span class="Comment"># this could be inferred to a different type such as Enumerable[float]</span>
    <span class="Identifier">o</span><span class="Operator">.</span><span class="Identifier">bar</span> <span class="Keyword">is</span> <span class="Keyword">distinct</span> <span class="Identifier">Enumerable</span>
    
    <span class="Comment"># it's also possible to give an alias name to a `bind many` type class</span>
    <span class="Keyword">type</span> <span class="Keyword">Enum</span> <span class="Operator">=</span> <span class="Keyword">distinct</span> <span class="Identifier">Enumerable</span>
    <span class="Identifier">o</span><span class="Operator">.</span><span class="Identifier">baz</span> <span class="Keyword">is</span> <span class="Keyword">Enum</span></pre><p>On the other hand, using <tt class="docutils literal"><span class="pre">bind once</span></tt> types allows you to test for equivalent types used in multiple signatures, without actually requiring any concrete types, thus allowing you to encode implementation-defined types:</p>
<pre class="listing"><span class="Keyword">type</span>
  <span class="Identifier">MyConcept</span> <span class="Operator">=</span> <span class="Keyword">concept</span> <span class="Identifier">x</span>
    <span class="Keyword">type</span> <span class="Identifier">T1</span> <span class="Operator">=</span> <span class="Identifier">auto</span>
    <span class="Identifier">x</span><span class="Operator">.</span><span class="Identifier">foo</span><span class="Punctuation">(</span><span class="Identifier">T1</span><span class="Punctuation">)</span>
    <span class="Identifier">x</span><span class="Operator">.</span><span class="Identifier">bar</span><span class="Punctuation">(</span><span class="Identifier">T1</span><span class="Punctuation">)</span> <span class="Comment"># both procs must accept the same type</span>
    
    <span class="Keyword">type</span> <span class="Identifier">T2</span> <span class="Operator">=</span> <span class="Identifier">seq</span><span class="Punctuation">[</span><span class="Identifier">SomeNumber</span><span class="Punctuation">]</span>
    <span class="Identifier">x</span><span class="Operator">.</span><span class="Identifier">alpha</span><span class="Punctuation">(</span><span class="Identifier">T2</span><span class="Punctuation">)</span>
    <span class="Identifier">x</span><span class="Operator">.</span><span class="Identifier">omega</span><span class="Punctuation">(</span><span class="Identifier">T2</span><span class="Punctuation">)</span> <span class="Comment"># both procs must accept the same type</span>
                <span class="Comment"># and it must be a numeric sequence</span></pre><p>As seen in the previous examples, you can refer to generic concepts such as <tt class="docutils literal"><span class="pre">Enumerable[T]</span></tt> just by their short name. Much like the regular generic types, the concept will be automatically instantiated with the bind once auto type in the place of each missing generic param.</p>
<p>Please note that generic concepts such as <tt class="docutils literal"><span class="pre">Enumerable[T]</span></tt> can be matched against concrete types such as <tt class="docutils literal"><span class="pre">string</span></tt>. Nim doesn't require the concept type to have the same number of parameters as the type being matched. If you wish to express a requirement towards the generic parameters of the matched type, you can use a type mapping operator such as <tt class="docutils literal"><span class="pre">genericHead</span></tt> or <tt class="docutils literal"><span class="pre">stripGenericParams</span></tt> within the body of the concept to obtain the uninstantiated version of the type, which you can then try to instantiate in any required way. For example, here is how one might define the classic <tt class="docutils literal"><span class="pre">Functor</span></tt> concept from Haskell and then demonstrate that Nim's <tt class="docutils literal"><span class="pre">Option[T]</span></tt> type is an instance of it:</p>
<pre class="listing"><span class="Keyword">import</span> <span class="Identifier">sugar</span><span class="Punctuation">,</span> <span class="Identifier">typetraits</span>

<span class="Keyword">type</span>
  <span class="Identifier">Functor</span><span class="Punctuation">[</span><span class="Identifier">A</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Keyword">concept</span> <span class="Identifier">f</span>
    <span class="Keyword">type</span> <span class="Identifier">MatchedGenericType</span> <span class="Operator">=</span> <span class="Identifier">genericHead</span><span class="Punctuation">(</span><span class="Identifier">typeof</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">)</span><span class="Punctuation">)</span>
      <span class="Comment"># `f` will be a value of a type such as `Option[T]`</span>
      <span class="Comment"># `MatchedGenericType` will become the `Option` type</span>
    
    <span class="Identifier">f</span><span class="Operator">.</span><span class="Identifier">val</span> <span class="Keyword">is</span> <span class="Identifier">A</span>
      <span class="Comment"># The Functor should provide a way to obtain</span>
      <span class="Comment"># a value stored inside it</span>
    
    <span class="Keyword">type</span> <span class="Identifier">T</span> <span class="Operator">=</span> <span class="Identifier">auto</span>
    <span class="Identifier">map</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">,</span> <span class="Identifier">A</span> <span class="Operator">-&gt;</span> <span class="Identifier">T</span><span class="Punctuation">)</span> <span class="Keyword">is</span> <span class="Identifier">MatchedGenericType</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span>
      <span class="Comment"># And it should provide a way to map one instance of</span>
      <span class="Comment"># the Functor to a instance of a different type, given</span>
      <span class="Comment"># a suitable `map` operation for the enclosed values</span>

<span class="Keyword">import</span> <span class="Identifier">options</span>
<span class="Identifier">echo</span> <span class="Identifier">Option</span><span class="Punctuation">[</span><span class="Identifier">int</span><span class="Punctuation">]</span> <span class="Keyword">is</span> <span class="Identifier">Functor</span> <span class="Comment"># prints true</span></pre>
<h2><a class="toc-backref" id="concepts-concept-derived-values" href="#concepts-concept-derived-values">Concept derived values</a></h2><p>All top level constants or types appearing within the concept body are accessible through the dot operator in procs where the concept was successfully matched to a concrete type:</p>
<pre class="listing"><span class="Keyword">type</span>
  <span class="Identifier">DateTime</span> <span class="Operator">=</span> <span class="Keyword">concept</span> <span class="Identifier">t1</span><span class="Punctuation">,</span> <span class="Identifier">t2</span><span class="Punctuation">,</span> <span class="Keyword">type</span> <span class="Identifier">T</span>
    <span class="Keyword">const</span> <span class="Identifier">Min</span> <span class="Operator">=</span> <span class="Identifier">T</span><span class="Operator">.</span><span class="Identifier">MinDate</span>
    <span class="Identifier">T</span><span class="Operator">.</span><span class="Identifier">Now</span> <span class="Keyword">is</span> <span class="Identifier">T</span>
    
    <span class="Identifier">t1</span> <span class="Operator">&lt;</span> <span class="Identifier">t2</span> <span class="Keyword">is</span> <span class="Identifier">bool</span>
    
    <span class="Keyword">type</span> <span class="Identifier">TimeSpan</span> <span class="Operator">=</span> <span class="Identifier">typeof</span><span class="Punctuation">(</span><span class="Identifier">t1</span> <span class="Operator">-</span> <span class="Identifier">t2</span><span class="Punctuation">)</span>
    <span class="Identifier">TimeSpan</span> <span class="Operator">*</span> <span class="Identifier">int</span> <span class="Keyword">is</span> <span class="Identifier">TimeSpan</span>
    <span class="Identifier">TimeSpan</span> <span class="Operator">+</span> <span class="Identifier">TimeSpan</span> <span class="Keyword">is</span> <span class="Identifier">TimeSpan</span>
    
    <span class="Identifier">t1</span> <span class="Operator">+</span> <span class="Identifier">TimeSpan</span> <span class="Keyword">is</span> <span class="Identifier">T</span>

<span class="Keyword">proc</span> <span class="Identifier">eventsJitter</span><span class="Punctuation">(</span><span class="Identifier">events</span><span class="Punctuation">:</span> <span class="Identifier">Enumerable</span><span class="Punctuation">[</span><span class="Identifier">DateTime</span><span class="Punctuation">]</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">float</span> <span class="Operator">=</span>
  <span class="Keyword">var</span>
    <span class="Comment"># this variable will have the inferred TimeSpan type for</span>
    <span class="Comment"># the concrete Date-like value the proc was called with:</span>
    <span class="Identifier">averageInterval</span><span class="Punctuation">:</span> <span class="Identifier">DateTime</span><span class="Operator">.</span><span class="Identifier">TimeSpan</span>
    
    <span class="Identifier">deviation</span><span class="Punctuation">:</span> <span class="Identifier">float</span>
  <span class="Operator">...</span></pre>
<h2><a class="toc-backref" id="concepts-concept-refinement" href="#concepts-concept-refinement">Concept refinement</a></h2><p>When the matched type within a concept is directly tested against a different concept, we say that the outer concept is a refinement of the inner concept and thus it is more-specific. When both concepts are matched in a call during overload resolution, Nim will assign a higher precedence to the most specific one. As an alternative way of defining concept refinements, you can use the object inheritance syntax involving the <tt class="docutils literal"><span class="pre">of</span></tt> keyword:</p>
<pre class="listing"><span class="Keyword">type</span>
  <span class="Identifier">Graph</span> <span class="Operator">=</span> <span class="Keyword">concept</span> <span class="Identifier">g</span><span class="Punctuation">,</span> <span class="Keyword">type</span> <span class="Identifier">G</span> <span class="Keyword">of</span> <span class="Identifier">EquallyComparable</span><span class="Punctuation">,</span> <span class="Identifier">Copyable</span>
    <span class="Keyword">type</span>
      <span class="Identifier">VertexType</span> <span class="Operator">=</span> <span class="Identifier">G</span><span class="Operator">.</span><span class="Identifier">VertexType</span>
      <span class="Identifier">EdgeType</span> <span class="Operator">=</span> <span class="Identifier">G</span><span class="Operator">.</span><span class="Identifier">EdgeType</span>
    
    <span class="Identifier">VertexType</span> <span class="Keyword">is</span> <span class="Identifier">Copyable</span>
    <span class="Identifier">EdgeType</span> <span class="Keyword">is</span> <span class="Identifier">Copyable</span>
    
    <span class="Keyword">var</span>
      <span class="Identifier">v</span><span class="Punctuation">:</span> <span class="Identifier">VertexType</span>
      <span class="Identifier">e</span><span class="Punctuation">:</span> <span class="Identifier">EdgeType</span>
  
  <span class="Identifier">IncidendeGraph</span> <span class="Operator">=</span> <span class="Keyword">concept</span> <span class="Keyword">of</span> <span class="Identifier">Graph</span>
    <span class="Comment"># symbols such as variables and types from the refined</span>
    <span class="Comment"># concept are automatically in scope:</span>
    
    <span class="Identifier">g</span><span class="Operator">.</span><span class="Identifier">source</span><span class="Punctuation">(</span><span class="Identifier">e</span><span class="Punctuation">)</span> <span class="Keyword">is</span> <span class="Identifier">VertexType</span>
    <span class="Identifier">g</span><span class="Operator">.</span><span class="Identifier">target</span><span class="Punctuation">(</span><span class="Identifier">e</span><span class="Punctuation">)</span> <span class="Keyword">is</span> <span class="Identifier">VertexType</span>
    
    <span class="Identifier">g</span><span class="Operator">.</span><span class="Identifier">outgoingEdges</span><span class="Punctuation">(</span><span class="Identifier">v</span><span class="Punctuation">)</span> <span class="Keyword">is</span> <span class="Identifier">Enumerable</span><span class="Punctuation">[</span><span class="Identifier">EdgeType</span><span class="Punctuation">]</span>
  
  <span class="Identifier">BidirectionalGraph</span> <span class="Operator">=</span> <span class="Keyword">concept</span> <span class="Identifier">g</span><span class="Punctuation">,</span> <span class="Keyword">type</span> <span class="Identifier">G</span>
    <span class="Comment"># The following will also turn the concept into a refinement when it</span>
    <span class="Comment"># comes to overload resolution, but it doesn't provide the convenient</span>
    <span class="Comment"># symbol inheritance</span>
    <span class="Identifier">g</span> <span class="Keyword">is</span> <span class="Identifier">IncidendeGraph</span>
    
    <span class="Identifier">g</span><span class="Operator">.</span><span class="Identifier">incomingEdges</span><span class="Punctuation">(</span><span class="Identifier">G</span><span class="Operator">.</span><span class="Identifier">VertexType</span><span class="Punctuation">)</span> <span class="Keyword">is</span> <span class="Identifier">Enumerable</span><span class="Punctuation">[</span><span class="Identifier">G</span><span class="Operator">.</span><span class="Identifier">EdgeType</span><span class="Punctuation">]</span>

<span class="Keyword">proc</span> <span class="Identifier">f</span><span class="Punctuation">(</span><span class="Identifier">g</span><span class="Punctuation">:</span> <span class="Identifier">IncidendeGraph</span><span class="Punctuation">)</span>
<span class="Keyword">proc</span> <span class="Identifier">f</span><span class="Punctuation">(</span><span class="Identifier">g</span><span class="Punctuation">:</span> <span class="Identifier">BidirectionalGraph</span><span class="Punctuation">)</span> <span class="Comment"># this one will be preferred if we pass a type</span>
                              <span class="Comment"># matching the BidirectionalGraph concept</span></pre>
<h1><a class="toc-backref" id="type-bound-operations" href="#type-bound-operations">Type bound operations</a></h1><p>There are 4 operations that are bound to a type:</p>
<ol class="simple"><li>Assignment</li>
<li>Moves</li>
<li>Destruction</li>
<li>Deep copying for communication between threads</li>
</ol>
<p>These operations can be <em>overridden</em> instead of <em>overloaded</em>. This means the implementation is automatically lifted to structured types. For instance if type <tt class="docutils literal"><span class="pre">T</span></tt> has an overridden assignment operator <tt class="docutils literal"><span class="pre">=</span></tt> this operator is also used for assignments of the type <tt class="docutils literal"><span class="pre">seq[T]</span></tt>. Since these operations are bound to a type they have to be bound to a nominal type for reasons of simplicity of implementation: This means an overridden <tt class="docutils literal"><span class="pre">deepCopy</span></tt> for <tt class="docutils literal"><span class="pre">ref T</span></tt> is really bound to <tt class="docutils literal"><span class="pre">T</span></tt> and not to <tt class="docutils literal"><span class="pre">ref T</span></tt>. This also means that one cannot override <tt class="docutils literal"><span class="pre">deepCopy</span></tt> for both <tt class="docutils literal"><span class="pre">ptr T</span></tt> and <tt class="docutils literal"><span class="pre">ref T</span></tt> at the same time; instead a helper distinct or object type has to be used for one pointer type.</p>
<p>Assignments, moves and destruction are specified in the <a class="reference external" href="destructors.html">destructors</a> document.</p>

<h2><a class="toc-backref" id="type-bound-operations-deepcopy" href="#type-bound-operations-deepcopy">deepCopy</a></h2><p><tt class="docutils literal"><span class="pre">=deepCopy</span></tt> is a builtin that is invoked whenever data is passed to a <tt class="docutils literal"><span class="pre">spawn</span></tt>'ed proc to ensure memory safety. The programmer can override its behaviour for a specific <tt class="docutils literal"><span class="pre">ref</span></tt> or <tt class="docutils literal"><span class="pre">ptr</span></tt> type <tt class="docutils literal"><span class="pre">T</span></tt>. (Later versions of the language may weaken this restriction.)</p>
<p>The signature has to be:</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">=</span><span class="Identifier">deepCopy</span><span class="Punctuation">`</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">T</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">T</span></pre><p>This mechanism will be used by most data structures that support shared memory like channels to implement thread safe automatic memory management.</p>
<p>The builtin <tt class="docutils literal"><span class="pre">deepCopy</span></tt> can even clone closures and their environments. See the documentation of <a class="reference external" href="#parallel-amp-spawn-spawn-statement">spawn</a> for details.</p>

<h1><a class="toc-backref" id="case-statement-macros" href="#case-statement-macros">Case statement macros</a></h1><p>A macro that needs to be called <span id="match_1">match</span> can be used to rewrite <tt class="docutils literal"><span class="pre">case</span></tt> statements in order to implement <span id="pattern-matching_1">pattern matching</span> for certain types. The following example implements a simplistic form of pattern matching for tuples, leveraging the existing equality operator for tuples (as provided in <tt class="docutils literal"><span class="pre">system.==</span></tt>):</p>
<pre class="listing"><span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">experimental</span><span class="Punctuation">:</span> <span class="StringLit">&quot;caseStmtMacros&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span>

<span class="Keyword">import</span> <span class="Identifier">macros</span>

<span class="Keyword">macro</span> <span class="Identifier">match</span><span class="Punctuation">(</span><span class="Identifier">n</span><span class="Punctuation">:</span> <span class="Keyword">tuple</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">untyped</span> <span class="Operator">=</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">newTree</span><span class="Punctuation">(</span><span class="Identifier">nnkIfStmt</span><span class="Punctuation">)</span>
  <span class="Keyword">let</span> <span class="Identifier">selector</span> <span class="Operator">=</span> <span class="Identifier">n</span><span class="Punctuation">[</span><span class="DecNumber">0</span><span class="Punctuation">]</span>
  <span class="Keyword">for</span> <span class="Identifier">i</span> <span class="Keyword">in</span> <span class="DecNumber">1</span> <span class="Operator">..&lt;</span> <span class="Identifier">n</span><span class="Operator">.</span><span class="Identifier">len</span><span class="Punctuation">:</span>
    <span class="Keyword">let</span> <span class="Identifier">it</span> <span class="Operator">=</span> <span class="Identifier">n</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span>
    <span class="Keyword">case</span> <span class="Identifier">it</span><span class="Operator">.</span><span class="Identifier">kind</span>
    <span class="Keyword">of</span> <span class="Identifier">nnkElse</span><span class="Punctuation">,</span> <span class="Identifier">nnkElifBranch</span><span class="Punctuation">,</span> <span class="Identifier">nnkElifExpr</span><span class="Punctuation">,</span> <span class="Identifier">nnkElseExpr</span><span class="Punctuation">:</span>
      <span class="Identifier">result</span><span class="Operator">.</span><span class="Identifier">add</span> <span class="Identifier">it</span>
    <span class="Keyword">of</span> <span class="Identifier">nnkOfBranch</span><span class="Punctuation">:</span>
      <span class="Keyword">for</span> <span class="Identifier">j</span> <span class="Keyword">in</span> <span class="FloatNumber">0.</span><span class="Operator">.</span><span class="Identifier">it</span><span class="Operator">.</span><span class="Identifier">len</span><span class="Operator">-</span><span class="DecNumber">2</span><span class="Punctuation">:</span>
        <span class="Keyword">let</span> <span class="Identifier">cond</span> <span class="Operator">=</span> <span class="Identifier">newCall</span><span class="Punctuation">(</span><span class="StringLit">&quot;==&quot;</span><span class="Punctuation">,</span> <span class="Identifier">selector</span><span class="Punctuation">,</span> <span class="Identifier">it</span><span class="Punctuation">[</span><span class="Identifier">j</span><span class="Punctuation">]</span><span class="Punctuation">)</span>
        <span class="Identifier">result</span><span class="Operator">.</span><span class="Identifier">add</span> <span class="Identifier">newTree</span><span class="Punctuation">(</span><span class="Identifier">nnkElifBranch</span><span class="Punctuation">,</span> <span class="Identifier">cond</span><span class="Punctuation">,</span> <span class="Identifier">it</span><span class="Punctuation">[</span><span class="Operator">^</span><span class="DecNumber">1</span><span class="Punctuation">]</span><span class="Punctuation">)</span>
    <span class="Keyword">else</span><span class="Punctuation">:</span>
      <span class="Identifier">error</span> <span class="StringLit">&quot;'match' cannot handle this node&quot;</span><span class="Punctuation">,</span> <span class="Identifier">it</span>
  <span class="Identifier">echo</span> <span class="Identifier">repr</span> <span class="Identifier">result</span>

<span class="Keyword">case</span> <span class="Punctuation">(</span><span class="StringLit">&quot;foo&quot;</span><span class="Punctuation">,</span> <span class="DecNumber">78</span><span class="Punctuation">)</span>
<span class="Keyword">of</span> <span class="Punctuation">(</span><span class="StringLit">&quot;foo&quot;</span><span class="Punctuation">,</span> <span class="DecNumber">78</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">echo</span> <span class="StringLit">&quot;yes&quot;</span>
<span class="Keyword">of</span> <span class="Punctuation">(</span><span class="StringLit">&quot;bar&quot;</span><span class="Punctuation">,</span> <span class="DecNumber">88</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">echo</span> <span class="StringLit">&quot;no&quot;</span>
<span class="Keyword">else</span><span class="Punctuation">:</span> <span class="Keyword">discard</span></pre><p>Currently case statement macros must be enabled explicitly via <tt class="docutils literal"><span class="pre">{.experimental: &quot;caseStmtMacros&quot;.}</span></tt>.</p>
<p><tt class="docutils literal"><span class="pre">match</span></tt> macros are subject to overload resolution. First the <tt class="docutils literal"><span class="pre">case</span></tt>'s selector expression is used to determine which <tt class="docutils literal"><span class="pre">match</span></tt> macro to call. To this macro is then passed the complete <tt class="docutils literal"><span class="pre">case</span></tt> statement body and the macro is evaluated.</p>
<p>In other words, the macro needs to transform the full <tt class="docutils literal"><span class="pre">case</span></tt> statement but only the statement's selector expression is used to determine which macro to call.</p>

<h1><a class="toc-backref" id="term-rewriting-macros" href="#term-rewriting-macros">Term rewriting macros</a></h1><p>Term rewriting macros are macros or templates that have not only a <em>name</em> but also a <em>pattern</em> that is searched for after the semantic checking phase of the compiler: This means they provide an easy way to enhance the compilation pipeline with user defined optimizations:</p>
<pre class="listing"><span class="Keyword">template</span> <span class="Identifier">optMul</span><span class="Punctuation">{</span><span class="Punctuation">`</span><span class="Operator">*</span><span class="Punctuation">`</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="DecNumber">2</span><span class="Punctuation">)</span><span class="Punctuation">}</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span> <span class="Identifier">a</span><span class="Operator">+</span><span class="Identifier">a</span>

<span class="Keyword">let</span> <span class="Identifier">x</span> <span class="Operator">=</span> <span class="DecNumber">3</span>
<span class="Identifier">echo</span> <span class="Identifier">x</span> <span class="Operator">*</span> <span class="DecNumber">2</span></pre><p>The compiler now rewrites <tt class="docutils literal"><span class="pre">x * 2</span></tt> as <tt class="docutils literal"><span class="pre">x + x</span></tt>. The code inside the curlies is the pattern to match against. The operators <tt class="docutils literal"><span class="pre">*</span></tt>,  <tt class="docutils literal"><span class="pre">**</span></tt>, <tt class="docutils literal"><span class="pre">|</span></tt>, <tt class="docutils literal"><span class="pre">~</span></tt> have a special meaning in patterns if they are written in infix notation, so to match verbatim against <tt class="docutils literal"><span class="pre">*</span></tt> the ordinary function call syntax needs to be used.</p>
<p>Term rewriting macro are applied recursively, up to a limit. This means that if the result of a term rewriting macro is eligible for another rewriting, the compiler will try to perform it, and so on, until no more optimizations are applicable. To avoid putting the compiler into an infinite loop, there is a hard limit on how many times a single term rewriting macro can be applied. Once this limit has been passed, the term rewriting macro will be ignored.</p>
<p>Unfortunately optimizations are hard to get right and even the tiny example is <strong>wrong</strong>:</p>
<pre class="listing"><span class="Keyword">template</span> <span class="Identifier">optMul</span><span class="Punctuation">{</span><span class="Punctuation">`</span><span class="Operator">*</span><span class="Punctuation">`</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="DecNumber">2</span><span class="Punctuation">)</span><span class="Punctuation">}</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span> <span class="Identifier">a</span><span class="Operator">+</span><span class="Identifier">a</span>

<span class="Keyword">proc</span> <span class="Identifier">f</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;side effect!&quot;</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="DecNumber">55</span>

<span class="Identifier">echo</span> <span class="Identifier">f</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Operator">*</span> <span class="DecNumber">2</span></pre><p>We cannot duplicate 'a' if it denotes an expression that has a side effect! Fortunately Nim supports side effect analysis:</p>
<pre class="listing"><span class="Keyword">template</span> <span class="Identifier">optMul</span><span class="Punctuation">{</span><span class="Punctuation">`</span><span class="Operator">*</span><span class="Punctuation">`</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="DecNumber">2</span><span class="Punctuation">)</span><span class="Punctuation">}</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">{</span><span class="Identifier">noSideEffect</span><span class="Punctuation">}</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span> <span class="Identifier">a</span><span class="Operator">+</span><span class="Identifier">a</span>

<span class="Keyword">proc</span> <span class="Identifier">f</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;side effect!&quot;</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="DecNumber">55</span>

<span class="Identifier">echo</span> <span class="Identifier">f</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Operator">*</span> <span class="DecNumber">2</span> <span class="Comment"># not optimized ;-)</span></pre><p>You can make one overload matching with a constraint and one without, and the one with a constraint will have precedence, and so you can handle both cases differently.</p>
<p>So what about <tt class="docutils literal"><span class="pre">2 * a</span></tt>? We should tell the compiler <tt class="docutils literal"><span class="pre">*</span></tt> is commutative. We cannot really do that however as the following code only swaps arguments blindly:</p>
<pre class="listing"><span class="Keyword">template</span> <span class="Identifier">mulIsCommutative</span><span class="Punctuation">{</span><span class="Punctuation">`</span><span class="Operator">*</span><span class="Punctuation">`</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">)</span><span class="Punctuation">}</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span> <span class="Identifier">b</span><span class="Operator">*</span><span class="Identifier">a</span></pre><p>What optimizers really need to do is a <em>canonicalization</em>:</p>
<pre class="listing"><span class="Keyword">template</span> <span class="Identifier">canonMul</span><span class="Punctuation">{</span><span class="Punctuation">`</span><span class="Operator">*</span><span class="Punctuation">`</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">)</span><span class="Punctuation">}</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">{</span><span class="Identifier">lit</span><span class="Punctuation">}</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span> <span class="Identifier">b</span><span class="Operator">*</span><span class="Identifier">a</span></pre><p>The <tt class="docutils literal"><span class="pre">int{lit}</span></tt> parameter pattern matches against an expression of type <tt class="docutils literal"><span class="pre">int</span></tt>, but only if it's a literal.</p>

<h2><a class="toc-backref" id="term-rewriting-macros-parameter-constraints" href="#term-rewriting-macros-parameter-constraints">Parameter constraints</a></h2><p>The <span id="parameter-constraint_1">parameter constraint</span> expression can use the operators <tt class="docutils literal"><span class="pre">|</span></tt> (or), <tt class="docutils literal"><span class="pre">&amp;</span></tt> (and) and <tt class="docutils literal"><span class="pre">~</span></tt> (not) and the following predicates:</p>
<table border="1" class="docutils"><tr><th>Predicate</th><th>Meaning</th></tr>
<tr><td><tt class="docutils literal"><span class="pre">atom</span></tt></td><td>The matching node has no children.</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">lit</span></tt></td><td>The matching node is a literal like &quot;abc&quot;, 12.</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">sym</span></tt></td><td>The matching node must be a symbol (a bound identifier).</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">ident</span></tt></td><td>The matching node must be an identifier (an unbound identifier).</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">call</span></tt></td><td>The matching AST must be a call/apply expression.</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">lvalue</span></tt></td><td>The matching AST must be an lvalue.</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">sideeffect</span></tt></td><td>The matching AST must have a side effect.</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">nosideeffect</span></tt></td><td>The matching AST must have no side effect.</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">param</span></tt></td><td>A symbol which is a parameter.</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">genericparam</span></tt></td><td>A symbol which is a generic parameter.</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">module</span></tt></td><td>A symbol which is a module.</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">type</span></tt></td><td>A symbol which is a type.</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">var</span></tt></td><td>A symbol which is a variable.</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">let</span></tt></td><td>A symbol which is a <tt class="docutils literal"><span class="pre">let</span></tt> variable.</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">const</span></tt></td><td>A symbol which is a constant.</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">result</span></tt></td><td>The special <tt class="docutils literal"><span class="pre">result</span></tt> variable.</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">proc</span></tt></td><td>A symbol which is a proc.</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">method</span></tt></td><td>A symbol which is a method.</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">iterator</span></tt></td><td>A symbol which is an iterator.</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">converter</span></tt></td><td>A symbol which is a converter.</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">macro</span></tt></td><td>A symbol which is a macro.</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">template</span></tt></td><td>A symbol which is a template.</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">field</span></tt></td><td>A symbol which is a field in a tuple or an object.</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">enumfield</span></tt></td><td>A symbol which is a field in an enumeration.</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">forvar</span></tt></td><td>A for loop variable.</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">label</span></tt></td><td>A label (used in <tt class="docutils literal"><span class="pre">block</span></tt> statements).</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">nk*</span></tt></td><td>The matching AST must have the specified kind. (Example: <tt class="docutils literal"><span class="pre">nkIfStmt</span></tt> denotes an <tt class="docutils literal"><span class="pre">if</span></tt> statement.)</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">alias</span></tt></td><td>States that the marked parameter needs to alias with <em>some</em> other parameter.</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">noalias</span></tt></td><td>States that <em>every</em> other parameter must not alias with the marked parameter.</td></tr>
</table><p>Predicates that share their name with a keyword have to be escaped with backticks. The <tt class="docutils literal"><span class="pre">alias</span></tt> and <tt class="docutils literal"><span class="pre">noalias</span></tt> predicates refer not only to the matching AST, but also to every other bound parameter; syntactically they need to occur after the ordinary AST predicates:</p>
<pre class="listing"><span class="Keyword">template</span> <span class="Identifier">ex</span><span class="Punctuation">{</span><span class="Identifier">a</span> <span class="Operator">=</span> <span class="Identifier">b</span> <span class="Operator">+</span> <span class="Identifier">c</span><span class="Punctuation">}</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">{</span><span class="Identifier">noalias</span><span class="Punctuation">}</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">,</span> <span class="Identifier">c</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Comment"># this transformation is only valid if 'b' and 'c' do not alias 'a':</span>
  <span class="Identifier">a</span> <span class="Operator">=</span> <span class="Identifier">b</span>
  <span class="Identifier">inc</span> <span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">c</span></pre>
<h2><a class="toc-backref" id="term-rewriting-macros-pattern-operators" href="#term-rewriting-macros-pattern-operators">Pattern operators</a></h2><p>The operators <tt class="docutils literal"><span class="pre">*</span></tt>,  <tt class="docutils literal"><span class="pre">**</span></tt>, <tt class="docutils literal"><span class="pre">|</span></tt>, <tt class="docutils literal"><span class="pre">~</span></tt> have a special meaning in patterns if they are written in infix notation.</p>

<h3><a class="toc-backref" id="pattern-operators-the-bar-operator" href="#pattern-operators-the-bar-operator">The <tt class="docutils literal"><span class="pre">|</span></tt> operator</a></h3><p>The <tt class="docutils literal"><span class="pre">|</span></tt> operator if used as infix operator creates an ordered choice:</p>
<pre class="listing"><span class="Keyword">template</span> <span class="Identifier">t</span><span class="Punctuation">{</span><span class="DecNumber">0</span><span class="Operator">|</span><span class="DecNumber">1</span><span class="Punctuation">}</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">untyped</span> <span class="Operator">=</span> <span class="DecNumber">3</span>
<span class="Keyword">let</span> <span class="Identifier">a</span> <span class="Operator">=</span> <span class="DecNumber">1</span>
<span class="Comment"># outputs 3:</span>
<span class="Identifier">echo</span> <span class="Identifier">a</span></pre><p>The matching is performed after the compiler performed some optimizations like constant folding, so the following does not work:</p>
<pre class="listing"><span class="Keyword">template</span> <span class="Identifier">t</span><span class="Punctuation">{</span><span class="DecNumber">0</span><span class="Operator">|</span><span class="DecNumber">1</span><span class="Punctuation">}</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">untyped</span> <span class="Operator">=</span> <span class="DecNumber">3</span>
<span class="Comment"># outputs 1:</span>
<span class="Identifier">echo</span> <span class="DecNumber">1</span></pre><p>The reason is that the compiler already transformed the 1 into &quot;1&quot; for the <tt class="docutils literal"><span class="pre">echo</span></tt> statement. However, a term rewriting macro should not change the semantics anyway. In fact they can be deactivated with the <tt class="docutils literal"><span class="pre">--patterns:off</span></tt> command line option or temporarily with the <tt class="docutils literal"><span class="pre">patterns</span></tt> pragma.</p>

<h3><a class="toc-backref" id="pattern-operators-the-operator" href="#pattern-operators-the-operator">The <tt class="docutils literal"><span class="pre">{}</span></tt> operator</a></h3><p>A pattern expression can be bound to a pattern parameter via the <tt class="docutils literal"><span class="pre">expr{param}</span></tt> notation:</p>
<pre class="listing"><span class="Keyword">template</span> <span class="Identifier">t</span><span class="Punctuation">{</span><span class="Punctuation">(</span><span class="DecNumber">0</span><span class="Operator">|</span><span class="DecNumber">1</span><span class="Operator">|</span><span class="DecNumber">2</span><span class="Punctuation">)</span><span class="Punctuation">{</span><span class="Identifier">x</span><span class="Punctuation">}</span><span class="Punctuation">}</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">untyped</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">untyped</span> <span class="Operator">=</span> <span class="Identifier">x</span><span class="Operator">+</span><span class="DecNumber">1</span>
<span class="Keyword">let</span> <span class="Identifier">a</span> <span class="Operator">=</span> <span class="DecNumber">1</span>
<span class="Comment"># outputs 2:</span>
<span class="Identifier">echo</span> <span class="Identifier">a</span></pre>
<h3><a class="toc-backref" id="pattern-operators-the-tilde-operator" href="#pattern-operators-the-tilde-operator">The <tt class="docutils literal"><span class="pre">~</span></tt> operator</a></h3><p>The <tt class="docutils literal"><span class="pre">~</span></tt> operator is the <strong>not</strong> operator in patterns:</p>
<pre class="listing"><span class="Keyword">template</span> <span class="Identifier">t</span><span class="Punctuation">{</span><span class="Identifier">x</span> <span class="Operator">=</span> <span class="Punctuation">(</span><span class="Operator">~</span><span class="Identifier">x</span><span class="Punctuation">)</span><span class="Punctuation">{</span><span class="Identifier">y</span><span class="Punctuation">}</span> <span class="Keyword">and</span> <span class="Punctuation">(</span><span class="Operator">~</span><span class="Identifier">x</span><span class="Punctuation">)</span><span class="Punctuation">{</span><span class="Identifier">z</span><span class="Punctuation">}</span><span class="Punctuation">}</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">,</span> <span class="Identifier">z</span><span class="Punctuation">:</span> <span class="Identifier">bool</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Identifier">x</span> <span class="Operator">=</span> <span class="Identifier">y</span>
  <span class="Keyword">if</span> <span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">x</span> <span class="Operator">=</span> <span class="Identifier">z</span>

<span class="Keyword">var</span>
  <span class="Identifier">a</span> <span class="Operator">=</span> <span class="Identifier">false</span>
  <span class="Identifier">b</span> <span class="Operator">=</span> <span class="Identifier">true</span>
  <span class="Identifier">c</span> <span class="Operator">=</span> <span class="Identifier">false</span>
<span class="Identifier">a</span> <span class="Operator">=</span> <span class="Identifier">b</span> <span class="Keyword">and</span> <span class="Identifier">c</span>
<span class="Identifier">echo</span> <span class="Identifier">a</span></pre>
<h3><a class="toc-backref" id="pattern-operators-the-star-operator" href="#pattern-operators-the-star-operator">The <tt class="docutils literal"><span class="pre">*</span></tt> operator</a></h3><p>The <tt class="docutils literal"><span class="pre">*</span></tt> operator can <em>flatten</em> a nested binary expression like <tt class="docutils literal"><span class="pre">a &amp; b &amp; c</span></tt> to <tt class="docutils literal"><span class="pre">&amp;(a, b, c)</span></tt>:</p>
<pre class="listing"><span class="Keyword">var</span>
  <span class="Identifier">calls</span> <span class="Operator">=</span> <span class="DecNumber">0</span>

<span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">&amp;&amp;</span><span class="Punctuation">`</span><span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">varargs</span><span class="Punctuation">[</span><span class="Identifier">string</span><span class="Punctuation">]</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">string</span> <span class="Operator">=</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">s</span><span class="Punctuation">[</span><span class="DecNumber">0</span><span class="Punctuation">]</span>
  <span class="Keyword">for</span> <span class="Identifier">i</span> <span class="Keyword">in</span> <span class="FloatNumber">1.</span><span class="Operator">.</span><span class="Identifier">len</span><span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">)</span><span class="Operator">-</span><span class="DecNumber">1</span><span class="Punctuation">:</span> <span class="Identifier">result</span><span class="Operator">.</span><span class="Identifier">add</span> <span class="Identifier">s</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span>
  <span class="Identifier">inc</span> <span class="Identifier">calls</span>

<span class="Keyword">template</span> <span class="Identifier">optConc</span><span class="Punctuation">{</span> <span class="Punctuation">`</span><span class="Operator">&amp;&amp;</span><span class="Punctuation">`</span> <span class="Operator">*</span> <span class="Identifier">a</span> <span class="Punctuation">}</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">untyped</span> <span class="Operator">=</span> <span class="Operator">&amp;&amp;</span><span class="Identifier">a</span>

<span class="Keyword">let</span> <span class="Identifier">space</span> <span class="Operator">=</span> <span class="StringLit">&quot; &quot;</span>
<span class="Identifier">echo</span> <span class="StringLit">&quot;my&quot;</span> <span class="Operator">&amp;&amp;</span> <span class="Punctuation">(</span><span class="Identifier">space</span> <span class="Operator">&amp;</span> <span class="StringLit">&quot;awe&quot;</span> <span class="Operator">&amp;&amp;</span> <span class="StringLit">&quot;some &quot;</span> <span class="Punctuation">)</span> <span class="Operator">&amp;&amp;</span> <span class="StringLit">&quot;concat&quot;</span>

<span class="Comment"># check that it's been optimized properly:</span>
<span class="Identifier">doAssert</span> <span class="Identifier">calls</span> <span class="Operator">==</span> <span class="DecNumber">1</span></pre><p>The second operator of <tt class="docutils literal"><span class="pre">*</span></tt> must be a parameter; it is used to gather all the arguments. The expression <tt class="docutils literal"><span class="pre">&quot;my&quot; &amp;&amp; (space &amp; &quot;awe&quot; &amp;&amp; &quot;some &quot; ) &amp;&amp; &quot;concat&quot;</span></tt> is passed to <tt class="docutils literal"><span class="pre">optConc</span></tt> in <tt class="docutils literal"><span class="pre">a</span></tt> as a special list (of kind <tt class="docutils literal"><span class="pre">nkArgList</span></tt>) which is flattened into a call expression; thus the invocation of <tt class="docutils literal"><span class="pre">optConc</span></tt> produces:</p>
<pre class="listing"><span class="Punctuation">`</span><span class="Operator">&amp;&amp;</span><span class="Punctuation">`</span><span class="Punctuation">(</span><span class="StringLit">&quot;my&quot;</span><span class="Punctuation">,</span> <span class="Identifier">space</span> <span class="Operator">&amp;</span> <span class="StringLit">&quot;awe&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;some &quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;concat&quot;</span><span class="Punctuation">)</span></pre>
<h3><a class="toc-backref" id="pattern-operators-the-starstar-operator" href="#pattern-operators-the-starstar-operator">The <tt class="docutils literal"><span class="pre">**</span></tt> operator</a></h3><p>The <tt class="docutils literal"><span class="pre">**</span></tt> is much like the <tt class="docutils literal"><span class="pre">*</span></tt> operator, except that it gathers not only all the arguments, but also the matched operators in reverse polish notation:</p>
<pre class="listing"><span class="Keyword">import</span> <span class="Identifier">macros</span>

<span class="Keyword">type</span>
  <span class="Identifier">Matrix</span> <span class="Operator">=</span> <span class="Keyword">object</span>
    <span class="Identifier">dummy</span><span class="Punctuation">:</span> <span class="Identifier">int</span>

<span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">*</span><span class="Punctuation">`</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">Matrix</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">Matrix</span> <span class="Operator">=</span> <span class="Keyword">discard</span>
<span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">+</span><span class="Punctuation">`</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">Matrix</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">Matrix</span> <span class="Operator">=</span> <span class="Keyword">discard</span>
<span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">-</span><span class="Punctuation">`</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">Matrix</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">Matrix</span> <span class="Operator">=</span> <span class="Keyword">discard</span>
<span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">$</span><span class="Punctuation">`</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">Matrix</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">string</span> <span class="Operator">=</span> <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Operator">$</span><span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">dummy</span>
<span class="Keyword">proc</span> <span class="Identifier">mat21</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">Matrix</span> <span class="Operator">=</span>
  <span class="Identifier">result</span><span class="Operator">.</span><span class="Identifier">dummy</span> <span class="Operator">=</span> <span class="DecNumber">21</span>

<span class="Keyword">macro</span> <span class="Identifier">optM</span><span class="Punctuation">{</span> <span class="Punctuation">(</span><span class="Punctuation">`</span><span class="Operator">+</span><span class="Punctuation">`</span><span class="Operator">|</span><span class="Punctuation">`</span><span class="Operator">-</span><span class="Punctuation">`</span><span class="Operator">|</span><span class="Punctuation">`</span><span class="Operator">*</span><span class="Punctuation">`</span><span class="Punctuation">)</span> <span class="Operator">**</span> <span class="Identifier">a</span> <span class="Punctuation">}</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">Matrix</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">untyped</span> <span class="Operator">=</span>
  <span class="Identifier">echo</span> <span class="Identifier">treeRepr</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">)</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">newCall</span><span class="Punctuation">(</span><span class="RawData">bindSym&quot;mat21&quot;</span><span class="Punctuation">)</span>

<span class="Keyword">var</span> <span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">,</span> <span class="Identifier">z</span><span class="Punctuation">:</span> <span class="Identifier">Matrix</span>

<span class="Identifier">echo</span> <span class="Identifier">x</span> <span class="Operator">+</span> <span class="Identifier">y</span> <span class="Operator">*</span> <span class="Identifier">z</span> <span class="Operator">-</span> <span class="Identifier">x</span></pre><p>This passes the expression <tt class="docutils literal"><span class="pre">x + y * z - x</span></tt> to the <tt class="docutils literal"><span class="pre">optM</span></tt> macro as an <tt class="docutils literal"><span class="pre">nnkArgList</span></tt> node containing:<pre>
Arglist
  Sym &quot;x&quot;
  Sym &quot;y&quot;
  Sym &quot;z&quot;
  Sym &quot;*&quot;
  Sym &quot;+&quot;
  Sym &quot;x&quot;
  Sym &quot;-&quot;</pre>
</p>
<p>(Which is the reverse polish notation of <tt class="docutils literal"><span class="pre">x + y * z - x</span></tt>.)</p>

<h2><a class="toc-backref" id="term-rewriting-macros-parameters" href="#term-rewriting-macros-parameters">Parameters</a></h2><p>Parameters in a pattern are type checked in the matching process. If a parameter is of the type <tt class="docutils literal"><span class="pre">varargs</span></tt> it is treated specially and it can match 0 or more arguments in the AST to be matched against:</p>
<pre class="listing"><span class="Keyword">template</span> <span class="Identifier">optWrite</span><span class="Punctuation">{</span>
  <span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">,</span> <span class="Identifier">x</span><span class="Punctuation">)</span>
  <span class="Punctuation">(</span><span class="Punctuation">(</span><span class="Identifier">write</span><span class="Operator">|</span><span class="Identifier">writeLine</span><span class="Punctuation">)</span><span class="Punctuation">{</span><span class="Identifier">w</span><span class="Punctuation">}</span><span class="Punctuation">)</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">)</span>
<span class="Punctuation">}</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">varargs</span><span class="Punctuation">[</span><span class="Identifier">untyped</span><span class="Punctuation">]</span><span class="Punctuation">,</span> <span class="Identifier">f</span><span class="Punctuation">:</span> <span class="Identifier">File</span><span class="Punctuation">,</span> <span class="Identifier">w</span><span class="Punctuation">:</span> <span class="Identifier">untyped</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Identifier">w</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">,</span> <span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">)</span></pre>
<h2><a class="toc-backref" id="term-rewriting-macros-examplecolon-partial-evaluation" href="#term-rewriting-macros-examplecolon-partial-evaluation">Example: Partial evaluation</a></h2><p>The following example shows how some simple partial evaluation can be implemented with term rewriting:</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">p</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">;</span> <span class="Identifier">cond</span><span class="Punctuation">:</span> <span class="Identifier">bool</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Keyword">if</span> <span class="Identifier">cond</span><span class="Punctuation">:</span> <span class="Identifier">x</span> <span class="Operator">+</span> <span class="Identifier">y</span> <span class="Keyword">else</span><span class="Punctuation">:</span> <span class="Identifier">x</span> <span class="Operator">-</span> <span class="Identifier">y</span>

<span class="Keyword">template</span> <span class="Identifier">optP1</span><span class="Punctuation">{</span><span class="Identifier">p</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">,</span> <span class="Identifier">true</span><span class="Punctuation">)</span><span class="Punctuation">}</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">untyped</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">untyped</span> <span class="Operator">=</span> <span class="Identifier">x</span> <span class="Operator">+</span> <span class="Identifier">y</span>
<span class="Keyword">template</span> <span class="Identifier">optP2</span><span class="Punctuation">{</span><span class="Identifier">p</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">,</span> <span class="Identifier">false</span><span class="Punctuation">)</span><span class="Punctuation">}</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">untyped</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">untyped</span> <span class="Operator">=</span> <span class="Identifier">x</span> <span class="Operator">-</span> <span class="Identifier">y</span></pre>
<h2><a class="toc-backref" id="term-rewriting-macros-examplecolon-hoisting" href="#term-rewriting-macros-examplecolon-hoisting">Example: Hoisting</a></h2><p>The following example shows how some form of hoisting can be implemented:</p>
<pre class="listing"><span class="Keyword">import</span> <span class="Identifier">pegs</span>

<span class="Keyword">template</span> <span class="Identifier">optPeg</span><span class="Punctuation">{</span><span class="Identifier">peg</span><span class="Punctuation">(</span><span class="Identifier">pattern</span><span class="Punctuation">)</span><span class="Punctuation">}</span><span class="Punctuation">(</span><span class="Identifier">pattern</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">{</span><span class="Identifier">lit</span><span class="Punctuation">}</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">Peg</span> <span class="Operator">=</span>
  <span class="Keyword">var</span> <span class="Identifier">gl</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">global</span><span class="Punctuation">,</span> <span class="Identifier">gensym</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span> <span class="Identifier">peg</span><span class="Punctuation">(</span><span class="Identifier">pattern</span><span class="Punctuation">)</span>
  <span class="Identifier">gl</span>

<span class="Keyword">for</span> <span class="Identifier">i</span> <span class="Keyword">in</span> <span class="DecNumber">0</span> <span class="Operator">..</span> <span class="DecNumber">3</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="Identifier">match</span><span class="Punctuation">(</span><span class="StringLit">&quot;(a b c)&quot;</span><span class="Punctuation">,</span> <span class="RawData">peg&quot;'(' @ ')'&quot;</span><span class="Punctuation">)</span>
  <span class="Identifier">echo</span> <span class="Identifier">match</span><span class="Punctuation">(</span><span class="StringLit">&quot;W_HI_Le&quot;</span><span class="Punctuation">,</span> <span class="RawData">peg&quot;\y 'while'&quot;</span><span class="Punctuation">)</span></pre><p>The <tt class="docutils literal"><span class="pre">optPeg</span></tt> template optimizes the case of a peg constructor with a string literal, so that the pattern will only be parsed once at program startup and stored in a global <tt class="docutils literal"><span class="pre">gl</span></tt> which is then re-used. This optimization is called hoisting because it is comparable to classical loop hoisting.</p>

<h1><a class="toc-backref" id="ast-based-overloading" href="#ast-based-overloading">AST based overloading</a></h1><p>Parameter constraints can also be used for ordinary routine parameters; these constraints affect ordinary overloading resolution then:</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">optLit</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">{</span><span class="Identifier">lit</span><span class="Operator">|</span><span class="Punctuation">`</span><span class="Keyword">const</span><span class="Punctuation">`</span><span class="Punctuation">}</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;string literal&quot;</span>
<span class="Keyword">proc</span> <span class="Identifier">optLit</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;no string literal&quot;</span>

<span class="Keyword">const</span>
  <span class="Identifier">constant</span> <span class="Operator">=</span> <span class="StringLit">&quot;abc&quot;</span>

<span class="Keyword">var</span>
  <span class="Identifier">variable</span> <span class="Operator">=</span> <span class="StringLit">&quot;xyz&quot;</span>

<span class="Identifier">optLit</span><span class="Punctuation">(</span><span class="StringLit">&quot;literal&quot;</span><span class="Punctuation">)</span>
<span class="Identifier">optLit</span><span class="Punctuation">(</span><span class="Identifier">constant</span><span class="Punctuation">)</span>
<span class="Identifier">optLit</span><span class="Punctuation">(</span><span class="Identifier">variable</span><span class="Punctuation">)</span></pre><p>However, the constraints <tt class="docutils literal"><span class="pre">alias</span></tt> and <tt class="docutils literal"><span class="pre">noalias</span></tt> are not available in ordinary routines.</p>

<h1><a class="toc-backref" id="parallel-amp-spawn" href="#parallel-amp-spawn">Parallel &amp; Spawn</a></h1><p>Nim has two flavors of parallelism:</p>
<ol class="simple"><li><span id="structured_1">Structured</span> parallelism via the <tt class="docutils literal"><span class="pre">parallel</span></tt> statement.</li>
<li><span id="unstructured_1">Unstructured</span> parallelism via the standalone <tt class="docutils literal"><span class="pre">spawn</span></tt> statement.</li>
</ol>
<p>Nim has a builtin thread pool that can be used for CPU intensive tasks. For IO intensive tasks the <tt class="docutils literal"><span class="pre">async</span></tt> and <tt class="docutils literal"><span class="pre">await</span></tt> features should be used instead. Both parallel and spawn need the <a class="reference external" href="threadpool.html">threadpool</a> module to work.</p>
<p>Somewhat confusingly, <tt class="docutils literal"><span class="pre">spawn</span></tt> is also used in the <tt class="docutils literal"><span class="pre">parallel</span></tt> statement with slightly different semantics. <tt class="docutils literal"><span class="pre">spawn</span></tt> always takes a call expression of the form <tt class="docutils literal"><span class="pre">f(a, ...)</span></tt>. Let <tt class="docutils literal"><span class="pre">T</span></tt> be <tt class="docutils literal"><span class="pre">f</span></tt>'s return type. If <tt class="docutils literal"><span class="pre">T</span></tt> is <tt class="docutils literal"><span class="pre">void</span></tt> then <tt class="docutils literal"><span class="pre">spawn</span></tt>'s return type is also <tt class="docutils literal"><span class="pre">void</span></tt> otherwise it is <tt class="docutils literal"><span class="pre">FlowVar[T]</span></tt>.</p>
<p>Within a <tt class="docutils literal"><span class="pre">parallel</span></tt> section sometimes the <tt class="docutils literal"><span class="pre">FlowVar[T]</span></tt> is eliminated to <tt class="docutils literal"><span class="pre">T</span></tt>. This happens when <tt class="docutils literal"><span class="pre">T</span></tt> does not contain any GC'ed memory. The compiler can ensure the location in <tt class="docutils literal"><span class="pre">location = spawn f(...)</span></tt> is not read prematurely within a <tt class="docutils literal"><span class="pre">parallel</span></tt> section and so there is no need for the overhead of an indirection via <tt class="docutils literal"><span class="pre">FlowVar[T]</span></tt> to ensure correctness.</p>
<p><strong>Note</strong>: Currently exceptions are not propagated between <tt class="docutils literal"><span class="pre">spawn</span></tt>'ed tasks!</p>

<h2><a class="toc-backref" id="parallel-amp-spawn-spawn-statement" href="#parallel-amp-spawn-spawn-statement">Spawn statement</a></h2><p><span id="spawn_1">spawn</span> can be used to pass a task to the thread pool:</p>
<pre class="listing"><span class="Keyword">import</span> <span class="Identifier">threadpool</span>

<span class="Keyword">proc</span> <span class="Identifier">processLine</span><span class="Punctuation">(</span><span class="Identifier">line</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">discard</span> <span class="StringLit">&quot;do some heavy lifting here&quot;</span>

<span class="Keyword">for</span> <span class="Identifier">x</span> <span class="Keyword">in</span> <span class="Identifier">lines</span><span class="Punctuation">(</span><span class="StringLit">&quot;myinput.txt&quot;</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="Identifier">spawn</span> <span class="Identifier">processLine</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span>
<span class="Identifier">sync</span><span class="Punctuation">(</span><span class="Punctuation">)</span></pre><p>For reasons of type safety and implementation simplicity the expression that <tt class="docutils literal"><span class="pre">spawn</span></tt> takes is restricted:</p>
<ul class="simple"><li>It must be a call expression <tt class="docutils literal"><span class="pre">f(a, ...)</span></tt>.</li>
<li><tt class="docutils literal"><span class="pre">f</span></tt> must be <tt class="docutils literal"><span class="pre">gcsafe</span></tt>.</li>
<li><tt class="docutils literal"><span class="pre">f</span></tt> must not have the calling convention <tt class="docutils literal"><span class="pre">closure</span></tt>.</li>
<li><tt class="docutils literal"><span class="pre">f</span></tt>'s parameters may not be of type <tt class="docutils literal"><span class="pre">var</span></tt>. This means one has to use raw <tt class="docutils literal"><span class="pre">ptr</span></tt>'s for data passing reminding the programmer to be careful.</li>
<li><tt class="docutils literal"><span class="pre">ref</span></tt> parameters are deeply copied which is a subtle semantic change and can cause performance problems but ensures memory safety. This deep copy is performed via <tt class="docutils literal"><span class="pre">system.deepCopy</span></tt> and so can be overridden.</li>
<li>For <em>safe</em> data exchange between <tt class="docutils literal"><span class="pre">f</span></tt> and the caller a global <tt class="docutils literal"><span class="pre">TChannel</span></tt> needs to be used. However, since spawn can return a result, often no further communication is required.</li>
</ul>
<p><tt class="docutils literal"><span class="pre">spawn</span></tt> executes the passed expression on the thread pool and returns a <span id="data-flow-variable_1">data flow variable</span> <tt class="docutils literal"><span class="pre">FlowVar[T]</span></tt> that can be read from. The reading with the <tt class="docutils literal"><span class="pre">^</span></tt> operator is <strong>blocking</strong>. However, one can use <tt class="docutils literal"><span class="pre">blockUntilAny</span></tt> to wait on multiple flow variables at the same time:</p>
<pre class="listing"><span class="Keyword">import</span> <span class="Identifier">threadpool</span><span class="Punctuation">,</span> <span class="Operator">...</span>

<span class="Comment"># wait until 2 out of 3 servers received the update:</span>
<span class="Keyword">proc</span> <span class="Identifier">main</span> <span class="Operator">=</span>
  <span class="Keyword">var</span> <span class="Identifier">responses</span> <span class="Operator">=</span> <span class="Identifier">newSeq</span><span class="Punctuation">[</span><span class="Identifier">FlowVarBase</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="DecNumber">3</span><span class="Punctuation">)</span>
  <span class="Keyword">for</span> <span class="Identifier">i</span> <span class="Keyword">in</span> <span class="FloatNumber">0.</span><span class="Operator">.</span><span class="DecNumber">2</span><span class="Punctuation">:</span>
    <span class="Identifier">responses</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Identifier">spawn</span> <span class="Identifier">tellServer</span><span class="Punctuation">(</span><span class="Identifier">Update</span><span class="Punctuation">,</span> <span class="StringLit">&quot;key&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;value&quot;</span><span class="Punctuation">)</span>
  <span class="Keyword">var</span> <span class="Identifier">index</span> <span class="Operator">=</span> <span class="Identifier">blockUntilAny</span><span class="Punctuation">(</span><span class="Identifier">responses</span><span class="Punctuation">)</span>
  <span class="Identifier">assert</span> <span class="Identifier">index</span> <span class="Operator">&gt;=</span> <span class="DecNumber">0</span>
  <span class="Identifier">responses</span><span class="Operator">.</span><span class="Identifier">del</span><span class="Punctuation">(</span><span class="Identifier">index</span><span class="Punctuation">)</span>
  <span class="Keyword">discard</span> <span class="Identifier">blockUntilAny</span><span class="Punctuation">(</span><span class="Identifier">responses</span><span class="Punctuation">)</span></pre><p>Data flow variables ensure that no data races are possible. Due to technical limitations not every type <tt class="docutils literal"><span class="pre">T</span></tt> is possible in a data flow variable: <tt class="docutils literal"><span class="pre">T</span></tt> has to be of the type <tt class="docutils literal"><span class="pre">ref</span></tt>, <tt class="docutils literal"><span class="pre">string</span></tt>, <tt class="docutils literal"><span class="pre">seq</span></tt> or of a type that doesn't contain a type that is garbage collected. This restriction is not hard to work-around in practice.</p>

<h2><a class="toc-backref" id="parallel-amp-spawn-parallel-statement" href="#parallel-amp-spawn-parallel-statement">Parallel statement</a></h2><p>Example:</p>
<pre class="listing"><span class="Comment"># Compute PI in an inefficient way</span>
<span class="Keyword">import</span> <span class="Identifier">strutils</span><span class="Punctuation">,</span> <span class="Identifier">math</span><span class="Punctuation">,</span> <span class="Identifier">threadpool</span>
<span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">experimental</span><span class="Punctuation">:</span> <span class="StringLit">&quot;parallel&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span>

<span class="Keyword">proc</span> <span class="Identifier">term</span><span class="Punctuation">(</span><span class="Identifier">k</span><span class="Punctuation">:</span> <span class="Identifier">float</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">float</span> <span class="Operator">=</span> <span class="DecNumber">4</span> <span class="Operator">*</span> <span class="Identifier">math</span><span class="Operator">.</span><span class="Identifier">pow</span><span class="Punctuation">(</span><span class="Operator">-</span><span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="Identifier">k</span><span class="Punctuation">)</span> <span class="Operator">/</span> <span class="Punctuation">(</span><span class="DecNumber">2</span><span class="Operator">*</span><span class="Identifier">k</span> <span class="Operator">+</span> <span class="DecNumber">1</span><span class="Punctuation">)</span>

<span class="Keyword">proc</span> <span class="Identifier">pi</span><span class="Punctuation">(</span><span class="Identifier">n</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">float</span> <span class="Operator">=</span>
  <span class="Keyword">var</span> <span class="Identifier">ch</span> <span class="Operator">=</span> <span class="Identifier">newSeq</span><span class="Punctuation">[</span><span class="Identifier">float</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">n</span><span class="Operator">+</span><span class="DecNumber">1</span><span class="Punctuation">)</span>
  <span class="Identifier">parallel</span><span class="Punctuation">:</span>
    <span class="Keyword">for</span> <span class="Identifier">k</span> <span class="Keyword">in</span> <span class="FloatNumber">0.</span><span class="Operator">.</span><span class="Identifier">ch</span><span class="Operator">.</span><span class="Identifier">high</span><span class="Punctuation">:</span>
      <span class="Identifier">ch</span><span class="Punctuation">[</span><span class="Identifier">k</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Identifier">spawn</span> <span class="Identifier">term</span><span class="Punctuation">(</span><span class="Identifier">float</span><span class="Punctuation">(</span><span class="Identifier">k</span><span class="Punctuation">)</span><span class="Punctuation">)</span>
  <span class="Keyword">for</span> <span class="Identifier">k</span> <span class="Keyword">in</span> <span class="FloatNumber">0.</span><span class="Operator">.</span><span class="Identifier">ch</span><span class="Operator">.</span><span class="Identifier">high</span><span class="Punctuation">:</span>
    <span class="Identifier">result</span> <span class="Operator">+=</span> <span class="Identifier">ch</span><span class="Punctuation">[</span><span class="Identifier">k</span><span class="Punctuation">]</span>

<span class="Identifier">echo</span> <span class="Identifier">formatFloat</span><span class="Punctuation">(</span><span class="Identifier">pi</span><span class="Punctuation">(</span><span class="DecNumber">5000</span><span class="Punctuation">)</span><span class="Punctuation">)</span></pre><p>The parallel statement is the preferred mechanism to introduce parallelism in a Nim program. A subset of the Nim language is valid within a <tt class="docutils literal"><span class="pre">parallel</span></tt> section. This subset is checked during semantic analysis to be free of data races. A sophisticated <span id="disjoint-checker_1">disjoint checker</span> ensures that no data races are possible even though shared memory is extensively supported!</p>
<p>The subset is in fact the full language with the following restrictions / changes:</p>
<ul class="simple"><li><tt class="docutils literal"><span class="pre">spawn</span></tt> within a <tt class="docutils literal"><span class="pre">parallel</span></tt> section has special semantics.</li>
<li>Every location of the form <tt class="docutils literal"><span class="pre">a[i]</span></tt> and <tt class="docutils literal"><span class="pre">a[i..j]</span></tt> and <tt class="docutils literal"><span class="pre">dest</span></tt> where <tt class="docutils literal"><span class="pre">dest</span></tt> is part of the pattern <tt class="docutils literal"><span class="pre">dest = spawn f(...)</span></tt> has to be provably disjoint. This is called the <em>disjoint check</em>.</li>
<li>Every other complex location <tt class="docutils literal"><span class="pre">loc</span></tt> that is used in a spawned proc (<tt class="docutils literal"><span class="pre">spawn f(loc)</span></tt>) has to be immutable for the duration of the <tt class="docutils literal"><span class="pre">parallel</span></tt> section. This is called the <em>immutability check</em>. Currently it is not specified what exactly &quot;complex location&quot; means. We need to make this an optimization!</li>
<li>Every array access has to be provably within bounds. This is called the <em>bounds check</em>.</li>
<li>Slices are optimized so that no copy is performed. This optimization is not yet performed for ordinary slices outside of a <tt class="docutils literal"><span class="pre">parallel</span></tt> section.</li>
</ul>

<h1><a class="toc-backref" id="guards-and-locks" href="#guards-and-locks">Guards and locks</a></h1><p>Apart from <tt class="docutils literal"><span class="pre">spawn</span></tt> and <tt class="docutils literal"><span class="pre">parallel</span></tt> Nim also provides all the common low level concurrency mechanisms like locks, atomic intrinsics or condition variables.</p>
<p>Nim significantly improves on the safety of these features via additional pragmas:</p>
<ol class="simple"><li>A <span id="guard_1">guard</span> annotation is introduced to prevent data races.</li>
<li>Every access of a guarded memory location needs to happen in an appropriate <span id="locks_1">locks</span> statement.</li>
<li>Locks and routines can be annotated with <span id="lock-levels_1">lock levels</span> to allow potential deadlocks to be detected during semantic analysis.</li>
</ol>

<h2><a class="toc-backref" id="guards-and-locks-guards-and-the-locks-section" href="#guards-and-locks-guards-and-the-locks-section">Guards and the locks section</a></h2>
<h3><a class="toc-backref" id="guards-and-the-locks-section-protecting-global-variables" href="#guards-and-the-locks-section-protecting-global-variables">Protecting global variables</a></h3><p>Object fields and global variables can be annotated via a <tt class="docutils literal"><span class="pre">guard</span></tt> pragma:</p>
<pre class="listing"><span class="Keyword">var</span> <span class="Identifier">glock</span><span class="Punctuation">:</span> <span class="Identifier">TLock</span>
<span class="Keyword">var</span> <span class="Identifier">gdata</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">guard</span><span class="Punctuation">:</span> <span class="Identifier">glock</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">:</span> <span class="Identifier">int</span></pre><p>The compiler then ensures that every access of <tt class="docutils literal"><span class="pre">gdata</span></tt> is within a <tt class="docutils literal"><span class="pre">locks</span></tt> section:</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">invalid</span> <span class="Operator">=</span>
  <span class="Comment"># invalid: unguarded access:</span>
  <span class="Identifier">echo</span> <span class="Identifier">gdata</span>

<span class="Keyword">proc</span> <span class="Identifier">valid</span> <span class="Operator">=</span>
  <span class="Comment"># valid access:</span>
  <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">locks</span><span class="Punctuation">:</span> <span class="Punctuation">[</span><span class="Identifier">glock</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">:</span>
    <span class="Identifier">echo</span> <span class="Identifier">gdata</span></pre><p>Top level accesses to <tt class="docutils literal"><span class="pre">gdata</span></tt> are always allowed so that it can be initialized conveniently. It is <em>assumed</em> (but not enforced) that every top level statement is executed before any concurrent action happens.</p>
<p>The <tt class="docutils literal"><span class="pre">locks</span></tt> section deliberately looks ugly because it has no runtime semantics and should not be used directly! It should only be used in templates that also implement some form of locking at runtime:</p>
<pre class="listing"><span class="Keyword">template</span> <span class="Identifier">lock</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">TLock</span><span class="Punctuation">;</span> <span class="Identifier">body</span><span class="Punctuation">:</span> <span class="Identifier">untyped</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Identifier">pthread_mutex_lock</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">)</span>
  <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">locks</span><span class="Punctuation">:</span> <span class="Punctuation">[</span><span class="Identifier">a</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">:</span>
    <span class="Keyword">try</span><span class="Punctuation">:</span>
      <span class="Identifier">body</span>
    <span class="Keyword">finally</span><span class="Punctuation">:</span>
      <span class="Identifier">pthread_mutex_unlock</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">)</span></pre><p>The guard does not need to be of any particular type. It is flexible enough to model low level lockfree mechanisms:</p>
<pre class="listing"><span class="Keyword">var</span> <span class="Identifier">dummyLock</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">compileTime</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">:</span> <span class="Identifier">int</span>
<span class="Keyword">var</span> <span class="Identifier">atomicCounter</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">guard</span><span class="Punctuation">:</span> <span class="Identifier">dummyLock</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">:</span> <span class="Identifier">int</span>

<span class="Keyword">template</span> <span class="Identifier">atomicRead</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">untyped</span> <span class="Operator">=</span>
  <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">locks</span><span class="Punctuation">:</span> <span class="Punctuation">[</span><span class="Identifier">dummyLock</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">:</span>
    <span class="Identifier">memoryReadBarrier</span><span class="Punctuation">(</span><span class="Punctuation">)</span>
    <span class="Identifier">x</span>

<span class="Identifier">echo</span> <span class="Identifier">atomicRead</span><span class="Punctuation">(</span><span class="Identifier">atomicCounter</span><span class="Punctuation">)</span></pre><p>The <tt class="docutils literal"><span class="pre">locks</span></tt> pragma takes a list of lock expressions <tt class="docutils literal"><span class="pre">locks: [a, b, ...]</span></tt> in order to support <em>multi lock</em> statements. Why these are essential is explained in the <a class="reference external" href="#guards-and-locks-lock-levels">lock levels</a> section.</p>

<h3><a class="toc-backref" id="guards-and-the-locks-section-protecting-general-locations" href="#guards-and-the-locks-section-protecting-general-locations">Protecting general locations</a></h3><p>The <tt class="docutils literal"><span class="pre">guard</span></tt> annotation can also be used to protect fields within an object. The guard then needs to be another field within the same object or a global variable.</p>
<p>Since objects can reside on the heap or on the stack this greatly enhances the expressivity of the language:</p>
<pre class="listing"><span class="Keyword">type</span>
  <span class="Identifier">ProtectedCounter</span> <span class="Operator">=</span> <span class="Keyword">object</span>
    <span class="Identifier">v</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">guard</span><span class="Punctuation">:</span> <span class="Identifier">L</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">:</span> <span class="Identifier">int</span>
    <span class="Identifier">L</span><span class="Punctuation">:</span> <span class="Identifier">TLock</span>

<span class="Keyword">proc</span> <span class="Identifier">incCounters</span><span class="Punctuation">(</span><span class="Identifier">counters</span><span class="Punctuation">:</span> <span class="Keyword">var</span> <span class="Identifier">openArray</span><span class="Punctuation">[</span><span class="Identifier">ProtectedCounter</span><span class="Punctuation">]</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">for</span> <span class="Identifier">i</span> <span class="Keyword">in</span> <span class="FloatNumber">0.</span><span class="Operator">.</span><span class="Identifier">counters</span><span class="Operator">.</span><span class="Identifier">high</span><span class="Punctuation">:</span>
    <span class="Identifier">lock</span> <span class="Identifier">counters</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Identifier">L</span><span class="Punctuation">:</span>
      <span class="Identifier">inc</span> <span class="Identifier">counters</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Identifier">v</span></pre><p>The access to field <tt class="docutils literal"><span class="pre">x.v</span></tt> is allowed since its guard <tt class="docutils literal"><span class="pre">x.L</span></tt>  is active. After template expansion, this amounts to:</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">incCounters</span><span class="Punctuation">(</span><span class="Identifier">counters</span><span class="Punctuation">:</span> <span class="Keyword">var</span> <span class="Identifier">openArray</span><span class="Punctuation">[</span><span class="Identifier">ProtectedCounter</span><span class="Punctuation">]</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">for</span> <span class="Identifier">i</span> <span class="Keyword">in</span> <span class="FloatNumber">0.</span><span class="Operator">.</span><span class="Identifier">counters</span><span class="Operator">.</span><span class="Identifier">high</span><span class="Punctuation">:</span>
    <span class="Identifier">pthread_mutex_lock</span><span class="Punctuation">(</span><span class="Identifier">counters</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Identifier">L</span><span class="Punctuation">)</span>
    <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">locks</span><span class="Punctuation">:</span> <span class="Punctuation">[</span><span class="Identifier">counters</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Identifier">L</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">:</span>
      <span class="Keyword">try</span><span class="Punctuation">:</span>
        <span class="Identifier">inc</span> <span class="Identifier">counters</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Identifier">v</span>
      <span class="Keyword">finally</span><span class="Punctuation">:</span>
        <span class="Identifier">pthread_mutex_unlock</span><span class="Punctuation">(</span><span class="Identifier">counters</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Identifier">L</span><span class="Punctuation">)</span></pre><p>There is an analysis that checks that <tt class="docutils literal"><span class="pre">counters[i].L</span></tt> is the lock that corresponds to the protected location <tt class="docutils literal"><span class="pre">counters[i].v</span></tt>. This analysis is called <span id="path-analysis_1">path analysis</span> because it deals with paths to locations like <tt class="docutils literal"><span class="pre">obj.field[i].fieldB[j]</span></tt>.</p>
<p>The path analysis is <strong>currently unsound</strong>, but that doesn't make it useless. Two paths are considered equivalent if they are syntactically the same.</p>
<p>This means the following compiles (for now) even though it really should not:</p>
<pre class="listing"><span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">locks</span><span class="Punctuation">:</span> <span class="Punctuation">[</span><span class="Identifier">a</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Identifier">L</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">:</span>
  <span class="Identifier">inc</span> <span class="Identifier">i</span>
  <span class="Identifier">access</span> <span class="Identifier">a</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Identifier">v</span></pre>
<h2><a class="toc-backref" id="guards-and-locks-lock-levels" href="#guards-and-locks-lock-levels">Lock levels</a></h2><p>Lock levels are used to enforce a global locking order in order to detect potential deadlocks during semantic analysis. A lock level is an constant integer in the range 0..1_000. Lock level 0 means that no lock is acquired at all.</p>
<p>If a section of code holds a lock of level <tt class="docutils literal"><span class="pre">M</span></tt> than it can also acquire any lock of level <tt class="docutils literal"><span class="pre">N &lt; M</span></tt>. Another lock of level <tt class="docutils literal"><span class="pre">M</span></tt> cannot be acquired. Locks of the same level can only be acquired <em>at the same time</em> within a single <tt class="docutils literal"><span class="pre">locks</span></tt> section:</p>
<pre class="listing"><span class="Keyword">var</span> <span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">TLock</span><span class="Punctuation">[</span><span class="DecNumber">2</span><span class="Punctuation">]</span>
<span class="Keyword">var</span> <span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">TLock</span><span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">]</span>
<span class="Comment"># invalid locking order: TLock[1] cannot be acquired before TLock[2]:</span>
<span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">locks</span><span class="Punctuation">:</span> <span class="Punctuation">[</span><span class="Identifier">x</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">:</span>
  <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">locks</span><span class="Punctuation">:</span> <span class="Punctuation">[</span><span class="Identifier">a</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">:</span>
    <span class="Operator">...</span>
<span class="Comment"># valid locking order: TLock[2] acquired before TLock[1]:</span>
<span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">locks</span><span class="Punctuation">:</span> <span class="Punctuation">[</span><span class="Identifier">a</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">:</span>
  <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">locks</span><span class="Punctuation">:</span> <span class="Punctuation">[</span><span class="Identifier">x</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">:</span>
    <span class="Operator">...</span>

<span class="Comment"># invalid locking order: TLock[2] acquired before TLock[2]:</span>
<span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">locks</span><span class="Punctuation">:</span> <span class="Punctuation">[</span><span class="Identifier">a</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">:</span>
  <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">locks</span><span class="Punctuation">:</span> <span class="Punctuation">[</span><span class="Identifier">b</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">:</span>
    <span class="Operator">...</span>

<span class="Comment"># valid locking order, locks of the same level acquired at the same time:</span>
<span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">locks</span><span class="Punctuation">:</span> <span class="Punctuation">[</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">:</span>
  <span class="Operator">...</span></pre><p>Here is how a typical multilock statement can be implemented in Nim. Note how the runtime check is required to ensure a global ordering for two locks <tt class="docutils literal"><span class="pre">a</span></tt> and <tt class="docutils literal"><span class="pre">b</span></tt> of the same lock level:</p>
<pre class="listing"><span class="Keyword">template</span> <span class="Identifier">multilock</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Keyword">ptr</span> <span class="Identifier">TLock</span><span class="Punctuation">;</span> <span class="Identifier">body</span><span class="Punctuation">:</span> <span class="Identifier">untyped</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">if</span> <span class="Keyword">cast</span><span class="Punctuation">[</span><span class="Identifier">ByteAddress</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">)</span> <span class="Operator">&lt;</span> <span class="Keyword">cast</span><span class="Punctuation">[</span><span class="Identifier">ByteAddress</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">b</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
    <span class="Identifier">pthread_mutex_lock</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">)</span>
    <span class="Identifier">pthread_mutex_lock</span><span class="Punctuation">(</span><span class="Identifier">b</span><span class="Punctuation">)</span>
  <span class="Keyword">else</span><span class="Punctuation">:</span>
    <span class="Identifier">pthread_mutex_lock</span><span class="Punctuation">(</span><span class="Identifier">b</span><span class="Punctuation">)</span>
    <span class="Identifier">pthread_mutex_lock</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">)</span>
  <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">locks</span><span class="Punctuation">:</span> <span class="Punctuation">[</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">:</span>
    <span class="Keyword">try</span><span class="Punctuation">:</span>
      <span class="Identifier">body</span>
    <span class="Keyword">finally</span><span class="Punctuation">:</span>
      <span class="Identifier">pthread_mutex_unlock</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">)</span>
      <span class="Identifier">pthread_mutex_unlock</span><span class="Punctuation">(</span><span class="Identifier">b</span><span class="Punctuation">)</span></pre><p>Whole routines can also be annotated with a <tt class="docutils literal"><span class="pre">locks</span></tt> pragma that takes a lock level. This then means that the routine may acquire locks of up to this level. This is essential so that procs can be called within a <tt class="docutils literal"><span class="pre">locks</span></tt> section:</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">p</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">locks</span><span class="Punctuation">:</span> <span class="FloatNumber">3.</span><span class="Punctuation">}</span> <span class="Operator">=</span> <span class="Keyword">discard</span>

<span class="Keyword">var</span> <span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">TLock</span><span class="Punctuation">[</span><span class="DecNumber">4</span><span class="Punctuation">]</span>
<span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">locks</span><span class="Punctuation">:</span> <span class="Punctuation">[</span><span class="Identifier">a</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">:</span>
  <span class="Comment"># p's locklevel (3) is strictly less than a's (4) so the call is allowed:</span>
  <span class="Identifier">p</span><span class="Punctuation">(</span><span class="Punctuation">)</span></pre><p>As usual <tt class="docutils literal"><span class="pre">locks</span></tt> is an inferred effect and there is a subtype relation: <tt class="docutils literal"><span class="pre">proc () {.locks: N.}</span></tt> is a subtype of <tt class="docutils literal"><span class="pre">proc () {.locks: M.}</span></tt> iff (M &lt;= N).</p>
<p>The <tt class="docutils literal"><span class="pre">locks</span></tt> pragma can also take the special value <tt class="docutils literal"><span class="pre">&quot;unknown&quot;</span></tt>. This is useful in the context of dynamic method dispatching. In the following example, the compiler can infer a lock level of 0 for the <tt class="docutils literal"><span class="pre">base</span></tt> case. However, one of the overloaded methods calls a procvar which is potentially locking. Thus, the lock level of calling <tt class="docutils literal"><span class="pre">g.testMethod</span></tt> cannot be inferred statically, leading to compiler warnings. By using <tt class="docutils literal"><span class="pre">{.locks: &quot;unknown&quot;.}</span></tt>, the base method can be marked explicitly as having unknown lock level as well:</p>
<pre class="listing"><span class="Keyword">type</span> <span class="Identifier">SomeBase</span><span class="Operator">*</span> <span class="Operator">=</span> <span class="Keyword">ref</span> <span class="Keyword">object</span> <span class="Keyword">of</span> <span class="Identifier">RootObj</span>
<span class="Keyword">type</span> <span class="Identifier">SomeDerived</span><span class="Operator">*</span> <span class="Operator">=</span> <span class="Keyword">ref</span> <span class="Keyword">object</span> <span class="Keyword">of</span> <span class="Identifier">SomeBase</span>
  <span class="Identifier">memberProc</span><span class="Operator">*:</span> <span class="Keyword">proc</span> <span class="Punctuation">(</span><span class="Punctuation">)</span>

<span class="Keyword">method</span> <span class="Identifier">testMethod</span><span class="Punctuation">(</span><span class="Identifier">g</span><span class="Punctuation">:</span> <span class="Identifier">SomeBase</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">base</span><span class="Punctuation">,</span> <span class="Identifier">locks</span><span class="Punctuation">:</span> <span class="StringLit">&quot;unknown&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span> <span class="Keyword">discard</span>
<span class="Keyword">method</span> <span class="Identifier">testMethod</span><span class="Punctuation">(</span><span class="Identifier">g</span><span class="Punctuation">:</span> <span class="Identifier">SomeDerived</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">if</span> <span class="Identifier">g</span><span class="Operator">.</span><span class="Identifier">memberProc</span> <span class="Operator">!=</span> <span class="Keyword">nil</span><span class="Punctuation">:</span>
    <span class="Identifier">g</span><span class="Operator">.</span><span class="Identifier">memberProc</span><span class="Punctuation">(</span><span class="Punctuation">)</span></pre>
<h2><a class="toc-backref" id="guards-and-locks-norewrite-pragma" href="#guards-and-locks-norewrite-pragma">noRewrite pragma</a></h2><p>Term rewriting macros and templates are currently greedy and they will rewrite as long as there is a match. There was no way to ensure some rewrite happens only once, e.g. when rewriting term to same term plus extra content.</p>
<p><tt class="docutils literal"><span class="pre">noRewrite</span></tt> pragma can actually prevent further rewriting on marked code, e.g. with given example <tt class="docutils literal"><span class="pre">echo(&quot;ab&quot;)</span></tt> will be rewritten just once:</p>
<pre class="listing"><span class="Keyword">template</span> <span class="Identifier">pwnEcho</span><span class="Punctuation">{</span><span class="Identifier">echo</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span><span class="Punctuation">}</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">expr</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">noRewrite</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">:</span> <span class="Identifier">echo</span><span class="Punctuation">(</span><span class="StringLit">&quot;pwned!&quot;</span><span class="Punctuation">)</span>

<span class="Identifier">echo</span> <span class="StringLit">&quot;ab&quot;</span></pre><p><tt class="docutils literal"><span class="pre">noRewrite</span></tt> pragma can be useful to control term-rewriting macros recursion.</p>

<h1><a class="toc-backref" id="taint-mode" href="#taint-mode">Taint mode</a></h1><p>The Nim compiler and most parts of the standard library support a taint mode. Input strings are declared with the <span id="taintedstring_1">TaintedString</span> string type declared in the <tt class="docutils literal"><span class="pre">system</span></tt> module.</p>
<p>If the taint mode is turned on (via the <tt class="docutils literal"><span class="pre">--taintMode:on</span></tt> command line option) it is a distinct string type which helps to detect input validation errors:</p>
<pre class="listing"><span class="Identifier">echo</span> <span class="StringLit">&quot;your name: &quot;</span>
<span class="Keyword">var</span> <span class="Identifier">name</span><span class="Punctuation">:</span> <span class="Identifier">TaintedString</span> <span class="Operator">=</span> <span class="Identifier">stdin</span><span class="Operator">.</span><span class="Identifier">readline</span>
<span class="Comment"># it is safe here to output the name without any input validation, so</span>
<span class="Comment"># we simply convert `name` to string to make the compiler happy:</span>
<span class="Identifier">echo</span> <span class="StringLit">&quot;hi, &quot;</span><span class="Punctuation">,</span> <span class="Identifier">name</span><span class="Operator">.</span><span class="Identifier">string</span></pre><p>If the taint mode is turned off, <tt class="docutils literal"><span class="pre">TaintedString</span></tt> is simply an alias for <tt class="docutils literal"><span class="pre">string</span></tt>.</p>

<h1><a class="toc-backref" id="aliasing-restrictions-in-parameter-passing" href="#aliasing-restrictions-in-parameter-passing">Aliasing restrictions in parameter passing</a></h1><p><strong>Note</strong>: The aliasing restrictions are currently not enforced by the implementation and need to be fleshed out further.</p>
<p>&quot;Aliasing&quot; here means that the underlying storage locations overlap in memory at runtime. An &quot;output parameter&quot; is a parameter of type <tt class="docutils literal"><span class="pre">var T</span></tt>, an input parameter is any parameter that is not of type <tt class="docutils literal"><span class="pre">var</span></tt>.</p>
<ol class="simple"><li>Two output parameters should never be aliased.</li>
<li>An input and an output parameter should not be aliased.</li>
<li>An output parameter should never be aliased with a global or thread local variable referenced by the called proc.</li>
<li>An input parameter should not be aliased with a global or thread local variable updated by the called proc.</li>
</ol>
<p>One problem with rules 3 and 4 is that they affect specific global or thread local variables, but Nim's effect tracking only tracks &quot;uses no global variable&quot; via <tt class="docutils literal"><span class="pre">.noSideEffect</span></tt>. The rules 3 and 4 can also be approximated by a different rule:</p>
<ol class="simple"><li>A global or thread local variable (or a location derived from such a location) can only passed to a parameter of a <tt class="docutils literal"><span class="pre">.noSideEffect</span></tt> proc.</li>
</ol>

<h1><a class="toc-backref" id="noalias-annotation" href="#noalias-annotation">Noalias annotation</a></h1><p>Since version 1.4 of the Nim compiler, there is a <tt class="docutils literal"><span class="pre">.noalias</span></tt> annotation for variables and parameters. It is mapped directly to C/C++'s <tt class="docutils literal"><span class="pre">restrict</span></tt> keyword and means that the underlying pointer is pointing to a unique location in memory, no other aliases to this location exist. It is <em>unchecked</em> that this alias restriction is followed, if the restriction is violated, the backend optimizer is free to miscompile the code. This is an <strong>unsafe</strong> language feature.</p>
<p>Ideally in later versions of the language, the restriction will be enforced at compile time. (Which is also why the name <tt class="docutils literal"><span class="pre">noalias</span></tt> was choosen instead of a more verbose name like <tt class="docutils literal"><span class="pre">unsafeAssumeNoAlias</span></tt>.)</p>

<h1><a class="toc-backref" id="strict-funcs" href="#strict-funcs">Strict funcs</a></h1><p>Since version 1.4 a stricter definition of &quot;side effect&quot; is available. In addition to the existing rule that a side effect is calling a function with side effects the following rule is also enforced:</p>
<p>Any mutation to an object does count as a side effect if that object is reachable via a parameter that is not declared as a <tt class="docutils literal"><span class="pre">var</span></tt> parameter.</p>
<p>For example:</p>
<pre class="listing"><span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">experimental</span><span class="Punctuation">:</span> <span class="StringLit">&quot;strictFuncs&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span>

<span class="Keyword">type</span>
  <span class="Identifier">Node</span> <span class="Operator">=</span> <span class="Keyword">ref</span> <span class="Keyword">object</span>
    <span class="Identifier">le</span><span class="Punctuation">,</span> <span class="Identifier">ri</span><span class="Punctuation">:</span> <span class="Identifier">Node</span>
    <span class="Identifier">data</span><span class="Punctuation">:</span> <span class="Identifier">string</span>

<span class="Keyword">func</span> <span class="Identifier">len</span><span class="Punctuation">(</span><span class="Identifier">n</span><span class="Punctuation">:</span> <span class="Identifier">Node</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span>
  <span class="Comment"># valid: len does not have side effects</span>
  <span class="Keyword">var</span> <span class="Identifier">it</span> <span class="Operator">=</span> <span class="Identifier">n</span>
  <span class="Keyword">while</span> <span class="Identifier">it</span> <span class="Operator">!=</span> <span class="Keyword">nil</span><span class="Punctuation">:</span>
    <span class="Identifier">inc</span> <span class="Identifier">result</span>
    <span class="Identifier">it</span> <span class="Operator">=</span> <span class="Identifier">it</span><span class="Operator">.</span><span class="Identifier">ri</span>

<span class="Keyword">func</span> <span class="Identifier">mut</span><span class="Punctuation">(</span><span class="Identifier">n</span><span class="Punctuation">:</span> <span class="Identifier">Node</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">let</span> <span class="Identifier">m</span> <span class="Operator">=</span> <span class="Identifier">n</span> <span class="Comment"># is the statement that connected the mutation to the parameter</span>
  <span class="Identifier">m</span><span class="Operator">.</span><span class="Identifier">data</span> <span class="Operator">=</span> <span class="StringLit">&quot;yeah&quot;</span> <span class="Comment"># the mutation is here</span>
  <span class="Comment"># Error: 'mut' can have side effects</span>
  <span class="Comment"># an object reachable from 'n' is potentially mutated</span></pre><p>The algorithm behind this analysis is described in the <a class="reference external" href="#view-types-algorithm">view types section</a>.</p>

<h1><a class="toc-backref" id="view-types" href="#view-types">View types</a></h1><p><strong>Note</strong>:  <tt class="docutils literal"><span class="pre">--experimental:views</span></tt> is more effective with <tt class="docutils literal"><span class="pre">--experimental:strictFuncs</span></tt>.</p>
<p>A view type is a type that is or contains one of the following types:</p>
<ul class="simple"><li><tt class="docutils literal"><span class="pre">var T</span></tt> (mutable view into <tt class="docutils literal"><span class="pre">T</span></tt>)</li>
<li><tt class="docutils literal"><span class="pre">lent T</span></tt> (immutable view into <tt class="docutils literal"><span class="pre">T</span></tt>)</li>
<li><tt class="docutils literal"><span class="pre">openArray[T]</span></tt> (pair of (pointer to array of <tt class="docutils literal"><span class="pre">T</span></tt>, size))</li>
</ul>
<p>For example:</p>
<pre class="listing"><span class="Keyword">type</span>
  <span class="Identifier">View1</span> <span class="Operator">=</span> <span class="Keyword">var</span> <span class="Identifier">int</span>
  <span class="Identifier">View2</span> <span class="Operator">=</span> <span class="Identifier">openArray</span><span class="Punctuation">[</span><span class="Identifier">byte</span><span class="Punctuation">]</span>
  <span class="Identifier">View3</span> <span class="Operator">=</span> <span class="Identifier">lent</span> <span class="Identifier">string</span>
  <span class="Identifier">View4</span> <span class="Operator">=</span> <span class="Identifier">Table</span><span class="Punctuation">[</span><span class="Identifier">openArray</span><span class="Punctuation">[</span><span class="Identifier">char</span><span class="Punctuation">]</span><span class="Punctuation">,</span> <span class="Identifier">int</span><span class="Punctuation">]</span></pre><p>Exceptions to this rule are types constructed via <tt class="docutils literal"><span class="pre">ptr</span></tt> or <tt class="docutils literal"><span class="pre">proc</span></tt>. For example, the following types are <strong>not</strong> view types:</p>
<pre class="listing"><span class="Keyword">type</span>
  <span class="Identifier">NotView1</span> <span class="Operator">=</span> <span class="Keyword">proc</span> <span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">openArray</span><span class="Punctuation">[</span><span class="Identifier">int</span><span class="Punctuation">]</span><span class="Punctuation">)</span>
  <span class="Identifier">NotView2</span> <span class="Operator">=</span> <span class="Keyword">ptr</span> <span class="Identifier">openArray</span><span class="Punctuation">[</span><span class="Identifier">char</span><span class="Punctuation">]</span>
  <span class="Identifier">NotView3</span> <span class="Operator">=</span> <span class="Keyword">ptr</span> <span class="Identifier">array</span><span class="Punctuation">[</span><span class="DecNumber">4</span><span class="Punctuation">,</span> <span class="Keyword">var</span> <span class="Identifier">int</span><span class="Punctuation">]</span></pre><p>A <em>mutable</em> view type is a type that is or contains a <tt class="docutils literal"><span class="pre">var T</span></tt> type. An <em>immutable</em> view type is a view type that is not a mutable view type.</p>
<p>A <em>view</em> is a symbol (a let, var, const, etc.) that has a view type.</p>
<p>Since version 1.4 Nim allows view types to be used as local variables. This feature needs to be enabled via <tt class="docutils literal"><span class="pre">{.experimental: &quot;views&quot;.}</span></tt>.</p>
<p>A local variable of a view type <em>borrows</em> from the locations and it is statically enforced that the view does not outlive the location it was borrowed from.</p>
<p>For example:</p>
<pre class="listing"><span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">experimental</span><span class="Punctuation">:</span> <span class="StringLit">&quot;views&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span>

<span class="Keyword">proc</span> <span class="Identifier">take</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">openArray</span><span class="Punctuation">[</span><span class="Identifier">int</span><span class="Punctuation">]</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Identifier">echo</span> <span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">len</span>

<span class="Keyword">proc</span> <span class="Identifier">main</span><span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">seq</span><span class="Punctuation">[</span><span class="Identifier">int</span><span class="Punctuation">]</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">var</span> <span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">openArray</span><span class="Punctuation">[</span><span class="Identifier">int</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Identifier">s</span> <span class="Comment"># 'x' is a view into 's'</span>
  <span class="Comment"># it is checked that 'x' does not outlive 's' and</span>
  <span class="Comment"># that 's' is not mutated.</span>
  <span class="Keyword">for</span> <span class="Identifier">i</span> <span class="Keyword">in</span> <span class="DecNumber">0</span> <span class="Operator">..</span> <span class="Identifier">high</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
    <span class="Identifier">echo</span> <span class="Identifier">x</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span>
  <span class="Identifier">take</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span>
  
  <span class="Identifier">take</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Operator">.</span><span class="Identifier">toOpenArray</span><span class="Punctuation">(</span><span class="DecNumber">0</span><span class="Punctuation">,</span> <span class="DecNumber">1</span><span class="Punctuation">)</span><span class="Punctuation">)</span> <span class="Comment"># slicing remains possible</span>
  <span class="Keyword">let</span> <span class="Identifier">y</span> <span class="Operator">=</span> <span class="Identifier">x</span>  <span class="Comment"># create a view from a view</span>
  <span class="Identifier">take</span> <span class="Identifier">y</span>
  <span class="Comment"># it is checked that 'y' does not outlive 'x' and</span>
  <span class="Comment"># that 'x' is not mutated as long as 'y' lives.</span>


<span class="Identifier">main</span><span class="Punctuation">(</span><span class="Operator">@</span><span class="Punctuation">[</span><span class="DecNumber">11</span><span class="Punctuation">,</span> <span class="DecNumber">22</span><span class="Punctuation">,</span> <span class="DecNumber">33</span><span class="Punctuation">]</span><span class="Punctuation">)</span></pre><p>A local variable of a view type can borrow from a location derived from a parameter, another local variable, a global <tt class="docutils literal"><span class="pre">const</span></tt> or <tt class="docutils literal"><span class="pre">let</span></tt> symbol or a thread-local <tt class="docutils literal"><span class="pre">var</span></tt> or <tt class="docutils literal"><span class="pre">let</span></tt>.</p>
<p>Let <tt class="docutils literal"><span class="pre">p</span></tt> the proc that is analysed for the correctness of the borrow operation.</p>
<p>Let <tt class="docutils literal"><span class="pre">source</span></tt> be one of:</p>
<ul class="simple"><li>A formal parameter of <tt class="docutils literal"><span class="pre">p</span></tt>. Note that this does not cover parameters of inner procs.</li>
<li>The <tt class="docutils literal"><span class="pre">result</span></tt> symbol of <tt class="docutils literal"><span class="pre">p</span></tt>.</li>
<li>A local <tt class="docutils literal"><span class="pre">var</span></tt> or <tt class="docutils literal"><span class="pre">let</span></tt> or <tt class="docutils literal"><span class="pre">const</span></tt> of <tt class="docutils literal"><span class="pre">p</span></tt>. Note that this does not cover locals of inner procs.</li>
<li>A thread-local <tt class="docutils literal"><span class="pre">var</span></tt> or <tt class="docutils literal"><span class="pre">let</span></tt>.</li>
<li>A global <tt class="docutils literal"><span class="pre">let</span></tt> or <tt class="docutils literal"><span class="pre">const</span></tt>.</li>
<li>A constant array/seq/object/tuple constructor.</li>
</ul>

<h2><a class="toc-backref" id="view-types-path-expressions" href="#view-types-path-expressions">Path expressions</a></h2><p>A location derived from <tt class="docutils literal"><span class="pre">source</span></tt> is then defined as a path expression that has <tt class="docutils literal"><span class="pre">source</span></tt> as the owner. A path expression <tt class="docutils literal"><span class="pre">e</span></tt> is defined recursively:</p>
<ul class="simple"><li><tt class="docutils literal"><span class="pre">source</span></tt> itself is a path expression.</li>
<li>Container access like <tt class="docutils literal"><span class="pre">e[i]</span></tt> is a path expression.</li>
<li>Tuple access <tt class="docutils literal"><span class="pre">e[0]</span></tt> is a path expression.</li>
<li>Object field access <tt class="docutils literal"><span class="pre">e.field</span></tt> is a path expression.</li>
<li><tt class="docutils literal"><span class="pre">system.toOpenArray(e, ...)</span></tt> is a path expression.</li>
<li>Pointer dereference <tt class="docutils literal"><span class="pre">e[]</span></tt> is a path expression.</li>
<li>An address <tt class="docutils literal"><span class="pre">addr e</span></tt>, <tt class="docutils literal"><span class="pre">unsafeAddr e</span></tt> is a path expression.</li>
<li>A type conversion <tt class="docutils literal"><span class="pre">T(e)</span></tt> is a path expression.</li>
<li>A cast expression <tt class="docutils literal"><span class="pre">cast[T](e)</span></tt> is a path expression.</li>
<li><tt class="docutils literal"><span class="pre">f(e, ...)</span></tt> is a path expression if <tt class="docutils literal"><span class="pre">f</span></tt>'s return type is a view type. Because the view can only have been borrowed from <tt class="docutils literal"><span class="pre">e</span></tt>, we then know that owner of <tt class="docutils literal"><span class="pre">f(e, ...)</span></tt> is <tt class="docutils literal"><span class="pre">e</span></tt>.</li>
</ul>
<p>If a view type is used as a return type, the location must borrow from a location that is derived from the first parameter that is passed to the proc. See <a class="reference external" href="https://nim-lang.org/docs/manual.html#procedures-var-return-type">https://nim-lang.org/docs/manual.html#procedures-var-return-type</a> for details about how this is done for <tt class="docutils literal"><span class="pre">var T</span></tt>.</p>
<p>A mutable view can borrow from a mutable location, an immutable view can borrow from both a mutable or an immutable location.</p>
<p>The <em>duration</em> of a borrow is the span of commands beginning from the assignment to the view and ending with the last usage of the view.</p>
<p>For the duration of the borrow operation, no mutations to the borrowed locations may be performed except via the potentially mutable view that borrowed from the location. The borrowed location is said to be <em>sealed</em> during the borrow.</p>
<pre class="listing"><span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">experimental</span><span class="Punctuation">:</span> <span class="StringLit">&quot;views&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span>

<span class="Keyword">type</span>
  <span class="Identifier">Obj</span> <span class="Operator">=</span> <span class="Keyword">object</span>
    <span class="Identifier">field</span><span class="Punctuation">:</span> <span class="Identifier">string</span>

<span class="Keyword">proc</span> <span class="Identifier">dangerous</span><span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Keyword">var</span> <span class="Identifier">seq</span><span class="Punctuation">[</span><span class="Identifier">Obj</span><span class="Punctuation">]</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">let</span> <span class="Identifier">v</span><span class="Punctuation">:</span> <span class="Identifier">lent</span> <span class="Identifier">Obj</span> <span class="Operator">=</span> <span class="Identifier">s</span><span class="Punctuation">[</span><span class="DecNumber">0</span><span class="Punctuation">]</span> <span class="Comment"># seal 's'</span>
  <span class="Identifier">s</span><span class="Operator">.</span><span class="Identifier">setLen</span> <span class="DecNumber">0</span>  <span class="Comment"># prevented at compile-time because 's' is sealed.</span>
  <span class="Identifier">echo</span> <span class="Identifier">v</span><span class="Operator">.</span><span class="Identifier">field</span></pre><p>The scope of the view does not matter:</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">valid</span><span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Keyword">var</span> <span class="Identifier">seq</span><span class="Punctuation">[</span><span class="Identifier">Obj</span><span class="Punctuation">]</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">let</span> <span class="Identifier">v</span><span class="Punctuation">:</span> <span class="Identifier">lent</span> <span class="Identifier">Obj</span> <span class="Operator">=</span> <span class="Identifier">s</span><span class="Punctuation">[</span><span class="DecNumber">0</span><span class="Punctuation">]</span>  <span class="Comment"># begin of borrow</span>
  <span class="Identifier">echo</span> <span class="Identifier">v</span><span class="Operator">.</span><span class="Identifier">field</span>            <span class="Comment"># end of borrow</span>
  <span class="Identifier">s</span><span class="Operator">.</span><span class="Identifier">setLen</span> <span class="DecNumber">0</span>  <span class="Comment"># valid because 'v' isn't used afterwards</span></pre><p>The analysis requires as much precision about mutations as is reasonably obtainable, so it is more effective with the experimental <a class="reference external" href="#strict-funcs">strict funcs</a> feature. In other words <tt class="docutils literal"><span class="pre">--experimental:views</span></tt> works better with <tt class="docutils literal"><span class="pre">--experimental:strictFuncs</span></tt>.</p>
<p>The analysis is currently control flow insensitive:</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">invalid</span><span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Keyword">var</span> <span class="Identifier">seq</span><span class="Punctuation">[</span><span class="Identifier">Obj</span><span class="Punctuation">]</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">let</span> <span class="Identifier">v</span><span class="Punctuation">:</span> <span class="Identifier">lent</span> <span class="Identifier">Obj</span> <span class="Operator">=</span> <span class="Identifier">s</span><span class="Punctuation">[</span><span class="DecNumber">0</span><span class="Punctuation">]</span>
  <span class="Keyword">if</span> <span class="Identifier">false</span><span class="Punctuation">:</span>
    <span class="Identifier">s</span><span class="Operator">.</span><span class="Identifier">setLen</span> <span class="DecNumber">0</span>
  <span class="Identifier">echo</span> <span class="Identifier">v</span><span class="Operator">.</span><span class="Identifier">field</span></pre><p>In this example, the compiler assumes that <tt class="docutils literal"><span class="pre">s.setLen 0</span></tt> invalidates the borrow operation of <tt class="docutils literal"><span class="pre">v</span></tt> even though a human being can easily see that it will never do that at runtime.</p>

<h2><a class="toc-backref" id="view-types-start-of-a-borrow" href="#view-types-start-of-a-borrow">Start of a borrow</a></h2><p>A borrow starts with one of the following:</p>
<ul class="simple"><li>The assignment of a non-view-type to a view-type.</li>
<li>The assignment of a location that is derived from a local parameter to a view-type.</li>
</ul>

<h2><a class="toc-backref" id="view-types-end-of-a-borrow" href="#view-types-end-of-a-borrow">End of a borrow</a></h2><p>A borrow operation ends with the last usage of the view variable.</p>

<h2><a class="toc-backref" id="view-types-reborrows" href="#view-types-reborrows">Reborrows</a></h2><p>A view <tt class="docutils literal"><span class="pre">v</span></tt> can borrow from multiple different locations. However, the borrow is always the full span of <tt class="docutils literal"><span class="pre">v</span></tt>'s lifetime and every location that is borrowed from is sealed during <tt class="docutils literal"><span class="pre">v</span></tt>'s lifetime.</p>

<h2><a class="toc-backref" id="view-types-algorithm" href="#view-types-algorithm">Algorithm</a></h2><p>The following section is an outline of the algorithm that the current implementation uses. The algorithm performs two traversals over the AST of the procedure or global section of code that uses a view variable. No fixpoint iterations are performed, the complexity of the analysis is O(N) where N is the number of nodes of the AST.</p>
<p>The first pass over the AST computes the lifetime of each local variable based on a notion of an &quot;abstract time&quot;, in the implementation it's a simple integer that is incremented for every visited node.</p>
<p>In the second pass information about the underlying object &quot;graphs&quot; is computed. Let <tt class="docutils literal"><span class="pre">v</span></tt> be a parameter or a local variable. Let <tt class="docutils literal"><span class="pre">G(v)</span></tt> be the graph that <tt class="docutils literal"><span class="pre">v</span></tt> belongs to. A graph is defined by the set of variables that belong to the graph. Initially for all <tt class="docutils literal"><span class="pre">v</span></tt>: <tt class="docutils literal"><span class="pre">G(v) = {v}</span></tt>. Every variable can only be part of a single graph.</p>
<p>Assignments like <tt class="docutils literal"><span class="pre">a = b</span></tt> &quot;connect&quot; two variables, both variables end up in the same graph <tt class="docutils literal"><span class="pre">{a, b} = G(a) = G(b)</span></tt>. Unfortunately, the pattern to look for is much more complex than that and can involve multiple assignment targets and sources:<pre>
f(x, y) = g(a, b)</pre>
</p>
<p>connects <tt class="docutils literal"><span class="pre">x</span></tt> and <tt class="docutils literal"><span class="pre">y</span></tt> to <tt class="docutils literal"><span class="pre">a</span></tt> and <tt class="docutils literal"><span class="pre">b</span></tt>: <tt class="docutils literal"><span class="pre">G(x) = G(y) = G(a) = G(b) = {x, y, a, b}</span></tt>. A type based alias analysis rules out some of these combinations, for example a <tt class="docutils literal"><span class="pre">string</span></tt> value cannot possibly be connected to a <tt class="docutils literal"><span class="pre">seq[int]</span></tt>.</p>
<p>A pattern like <tt class="docutils literal"><span class="pre">v[] = value</span></tt> or <tt class="docutils literal"><span class="pre">v.field = value</span></tt> marks <tt class="docutils literal"><span class="pre">G(v)</span></tt> as mutated. After the second pass a set of disjoint graphs was computed.</p>
<p>For strict functions it is then enforced that there is no graph that is both mutated and has an element that is an immutable parameter (that is a parameter that is not of type <tt class="docutils literal"><span class="pre">var T</span></tt>).</p>
<p>For borrow checking a different set of checks is performed. Let <tt class="docutils literal"><span class="pre">v</span></tt> be the view and <tt class="docutils literal"><span class="pre">b</span></tt> the location that is borrowed from.</p>
<ul class="simple"><li>The lifetime of <tt class="docutils literal"><span class="pre">v</span></tt> must not exceed <tt class="docutils literal"><span class="pre">b</span></tt>'s lifetime. Note: The lifetime of a parameter is the complete proc body.</li>
<li>If <tt class="docutils literal"><span class="pre">v</span></tt> is a mutable view and <tt class="docutils literal"><span class="pre">v</span></tt> is used to actually mutate the borrowed location, then <tt class="docutils literal"><span class="pre">b</span></tt> has to be a mutable location. Note: If it is not actually used for mutation, borrowing a mutable view from an immutable location is allowed! This allows for many important idioms and will be justified in an upcoming RFC.</li>
<li>During <tt class="docutils literal"><span class="pre">v</span></tt>'s lifetime, <tt class="docutils literal"><span class="pre">G(b)</span></tt> can only be modified by <tt class="docutils literal"><span class="pre">v</span></tt> (and only if <tt class="docutils literal"><span class="pre">v</span></tt> is a mutable view).</li>
<li>If <tt class="docutils literal"><span class="pre">v</span></tt> is <tt class="docutils literal"><span class="pre">result</span></tt> then <tt class="docutils literal"><span class="pre">b</span></tt> has to be a location derived from the first formal parameter or from a constant location.</li>
<li>A view cannot be used for a read or a write access before it was assigned to.</li>
</ul>
</p>
  
  </div>
</div>

    <div class="row">
      <div class="twelve-columns footer">
        <span class="nim-sprite"></span>
        <br/>
        <small style="color: var(--hint);">Made with Nim. Generated: 2020-11-26 00:46:59 UTC</small>
      </div>
    </div>
  </div>
</div>

</body>
</html>
